{
    "version": "https://jsonfeed.org/version/1",
    "title": "峻峻尼的个人博客",
    "subtitle": "",
    "icon": "http://example.com/images/favicon.ico",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/02/27/2023.2.20/",
            "url": "http://example.com/2023/02/27/2023.2.20/",
            "title": "云计算 2023.2.20",
            "date_published": "2023-02-27T01:18:49.761Z",
            "content_html": "<h4 id=\"云计算是什么\"><a class=\"anchor\" href=\"#云计算是什么\">#</a> 云计算是什么？</h4>\n<p>​\t在传统模式下，用户通过使用实际的硬件设备，达到完成业务运行的目的，但基于实际设备运维成本较高，不利于用户的资源共享。</p>\n<p>​\t传统模式下，软件与硬件是紧密耦合状态，虚拟化之后，实现软硬件的解耦</p>\n<p>​\t云计算是通过资源整合后，基于服务器 / 硬件设备的集群，创建虚拟计算机，提供给用户使用</p>\n<h5 id=\"云计算优势\"><a class=\"anchor\" href=\"#云计算优势\">#</a> 云计算优势：</h5>\n<p>由于传统模式的成本高，因此可通过虚拟化的技术，将真实的物理资源整合，之后分配给不同的用户，以实现资源共享，对于厂商则将设备的商业价值最大化</p>\n<h5 id=\"云计算的构成\"><a class=\"anchor\" href=\"#云计算的构成\">#</a> 云计算的构成：</h5>\n<p>计算资源虚拟化 + 存储资源虚拟化 + 网络资源虚拟化 + Internet = 云计算</p>\n<h5 id=\"虚拟化是什么\"><a class=\"anchor\" href=\"#虚拟化是什么\">#</a> 虚拟化是什么：</h5>\n<p>虚拟化指将实际的设备通过虚拟化技术整合成虚拟资源池（计算 / 存储 / 网络），以租用的方式提供给用户，资源池中的资源是共享的，通过虚拟化实现资源的商业价值最大化，最终实现资源的复用率提高</p>\n<h5 id=\"云计算与虚拟化的关系\"><a class=\"anchor\" href=\"#云计算与虚拟化的关系\">#</a> 云计算与虚拟化的关系：</h5>\n<p>虚拟化是实现云计算的基础，云计算是将虚拟化提供给用户的商业模式</p>\n<h5 id=\"云计算服务类型\"><a class=\"anchor\" href=\"#云计算服务类型\">#</a> 云计算服务类型：</h5>\n<p>基础即服务 — — 硬件设施</p>\n<p>平台即服务 — — 操作系统</p>\n<p>软件即服务 — — 运行在系统之上的 APP</p>\n<h5 id=\"云计算的商业价值\"><a class=\"anchor\" href=\"#云计算的商业价值\">#</a> 云计算的商业价值：</h5>\n<p>私有云：针对个人所使用的云环境（针对特定用户）</p>\n<p>公有云：针对所有用户</p>\n<p>混合云：两种云环境结合使用</p>\n<p>行业云：属于私有云，只限于行业内部人员使用</p>\n<h5 id=\"云计算的优点通用点\"><a class=\"anchor\" href=\"#云计算的优点通用点\">#</a> 云计算的优点 / 通用点</h5>\n<p>按需自助的服务：根据用户的资源需求量，自助选择服务类型</p>\n<p>随时随地的网络接入：对于用户接入服务的地点，没有地域限制，只要有公网可达即可</p>\n<p>弹性伸缩的资源：根据用户的需求，可对资源进行伸缩</p>\n<p>可计量的收费方式：根据用户的使用情况，收取相应的费用</p>\n<p>资源池化：将所有的硬件资源，整合成资源池，达到资源共享的目的，从而提高资源复用率，节约用户成本</p>\n<p>大规模：由于虚拟化资源使用，必须基于底层设备的支持，因此根据发展情况，厂商会不断扩大底层硬件的规模</p>\n<p>安全性：虚拟化实现 封装 / 独立 / 分区 / 灵活迁移</p>\n<p>异构化 / 同构化</p>\n<h4 id=\"问题\"><a class=\"anchor\" href=\"#问题\">#</a> 问题：</h4>\n<h5 id=\"为什么需要云计算\"><a class=\"anchor\" href=\"#为什么需要云计算\">#</a> 为什么需要云计算：</h5>\n<p>​\t基于硬件设备的支持，提升运行的效率，提高资源的复用率，实现资源共享，节约成本</p>\n<h5 id=\"云计算实现方式\"><a class=\"anchor\" href=\"#云计算实现方式\">#</a> 云计算实现方式：</h5>\n<p>​\t以虚拟化作为基础，实现软硬件解耦，再分为不同的服务类型，以私有云 / 公有云 / 混合云 / 行业云出租给用户，实现商业价值的最大值</p>\n<h5 id=\"云计算是什么-2\"><a class=\"anchor\" href=\"#云计算是什么-2\">#</a> 云计算是什么？</h5>\n<p>​\t\t让用户创建虚拟计算机，并且使虚拟计算机最大程度接近于真实主机的运行。</p>\n<h5 id=\"虚拟化优势\"><a class=\"anchor\" href=\"#虚拟化优势\">#</a> 虚拟化优势：</h5>\n<p>​\t将资源池化，实现资源共享，提高资源复用率，降低成本</p>\n<h5 id=\"云计算与虚拟化的关系-2\"><a class=\"anchor\" href=\"#云计算与虚拟化的关系-2\">#</a> 云计算与虚拟化的关系：</h5>\n<p>​\t虚拟化是实现云计算的前提条件</p>\n<hr />\n<h4 id=\"计算虚拟化\"><a class=\"anchor\" href=\"#计算虚拟化\">#</a> 计算虚拟化</h4>\n<p>针对 CPU / 内存 / IO 读写，虚拟机在运行过程中，与底层设备之间交互的过程</p>\n<p>虚拟化层：将硬件资源进行虚拟化整合，分享</p>\n<h5 id=\"计算虚拟化架构\"><a class=\"anchor\" href=\"#计算虚拟化架构\">#</a> 计算虚拟化架构</h5>\n<p><strong>全虚拟化</strong>：将底层硬件全部整合成虚拟资源池，当虚拟机发送指令时，直接由虚拟化层处理回应，不会影响到底层，实现虚拟化目的，但性能最差</p>\n<p><strong>半虚拟化</strong>：虚拟机向底层发放指令时，先由虚拟化层拦截，再进行区分转发给底层，底层接收后，再经过虚拟化层转发给虚拟机，相比全虚在实现虚拟化的基础上性能提升</p>\n<p><strong>硬件辅助虚拟化</strong>：虚拟机与硬件层，一一对应，可直接通过虚拟化层，将指令发送给底层硬件，相对性能最好</p>\n<p>并且虚拟化层与底层硬件之间，分别根据主机，系统，软件等 分成 Ring0-Ring3 四个级别</p>\n<p>一般由<strong> Ring0</strong> 发出的指令都属于<strong>特权（敏感）指令</strong>，此种指令表明会对底层主机产生直接影响，对于主机的运行状态产生影响，</p>\n<p>所以<strong> Ring0</strong> 属于核心区域，底层主机和虚拟机所在的位置都属于<strong> Ring0</strong>,</p>\n<p><strong>Ring1</strong> 是系统所在层次，<strong>ring2</strong> 属于<strong>过渡层</strong>没有明确的对应位置，</p>\n<p><strong>ring3</strong> 对应应用软件层，并且由<strong> ring3</strong> 发出的指令属于<strong>普通指令</strong></p>\n<p>普通指令指只会影响底层资源的调用</p>\n<h5 id=\"计算虚拟化分类\"><a class=\"anchor\" href=\"#计算虚拟化分类\">#</a> 计算虚拟化分类：</h5>\n<p>​\t<strong>寄居虚拟化</strong> /<strong> 宿主虚拟化</strong>，在硬件设备上直接按照虚拟化操作系统（虚拟机），是否能运行正常，取决于底层是否支持，因此此种模式对硬件要求较高。</p>\n<p>​\t<strong>裸金属虚拟化</strong>，属于半虚拟化的一种，虚拟机属于内核态运行，依靠 XEN 虚拟化技术将虚拟机的指令统一处理下发到底层，但 XEN 开发难度大，安全性高，处理的效率较低，并且若虚拟化架构发生改变，则需重新开发</p>\n<p>​\t<strong>混合虚拟化</strong>，属于半虚拟化，但相比 XEN 技术，混合虚拟化依靠 KVM 技术运行，此种类型处理效率较高，相当于安装在虚拟化层的进程，不会因为架构改变而重新研发</p>\n<p>​\t<strong>操作系统虚拟化</strong>，指使用容器技术实现虚拟机运行，此种虚拟化模式下，多个虚拟机共享同一操作系统，因此独立和安全性不足</p>\n<p>​\t一型虚拟化：半虚拟化</p>\n<p>​\t二型虚拟化：寄居虚拟化</p>\n<h5 id=\"虚拟化技术的区别\"><a class=\"anchor\" href=\"#虚拟化技术的区别\">#</a> 虚拟化技术的区别</h5>\n<p><strong>XEN</strong>：在半虚拟化中，将虚拟化所有的指令统一转发给 DOM 0, 此区域是 XEN 的核心处理区域，其他虚拟机所在区域为 Dom U 区域，根据虚拟机个数的多少，可以存在多个 U 区域，而 0 区域只有一个，<strong>因此是一对多的关系</strong>，所以由于只由一个 0 区域统一处理，资源占用较大，效率较低，但安全性高</p>\n<p><strong>KVM</strong>：在半虚拟化中，把自身所有的核心 qemu 与不同的虚拟机形成对应，目的是加快虚拟机响应的速度，提升计算读写的处理效率，并且 KVM 的对应关系是可将 qemu<strong> 分成多个与虚拟机形成一一对应的关系</strong></p>\n<h5 id=\"计算虚拟化对象\"><a class=\"anchor\" href=\"#计算虚拟化对象\">#</a> 计算虚拟化对象：</h5>\n<p>​\t内存：针对于实际内存资源，通过虚拟化技术，实现内存资源使用 / 共享，依靠内存复用的虚拟化技术</p>\n<pre><code>1.\t 内存共享：用户使用相同的部分\n2.\t 内存气泡：先根据用户虚拟机的请求，进行资源分配，若在使用过程中，存在用户内存不足，则会将其他的空闲内存先挪用给当下继续使用，若后续其他用户需要使用时，则会重新分配资源\n3.\t 内存置换：指现有的内存全部已占用，若后续有新业务写入，则查看当前不需要经常读写的老业务，并且将其置换出来，空闲的空间则用于写入新的业务，若后续老业务需要读写，则再置换一次空间\n</code></pre>\n<p>​\tcpu：针对实际的 CPU 内核，实现虚拟化的资源共享</p>\n<p>​\ti/o 读写：通过虚拟化的技术，能够让虚拟机接近于真实主机的运行 依靠半虚 / 硬件辅助等方式，将虚拟机的所有指令下发到底层，完成虚拟机的正常读写。</p>\n<h4 id=\"问题-2\"><a class=\"anchor\" href=\"#问题-2\">#</a> 问题：</h4>\n<h5 id=\"1-xen和kvm的区别\"><a class=\"anchor\" href=\"#1-xen和kvm的区别\">#</a> 1 XEN 和 KVM 的区别</h5>\n<h5 id=\"2-内存复用如何实现\"><a class=\"anchor\" href=\"#2-内存复用如何实现\">#</a> 2 内存复用如何实现</h5>\n<p>通过内存共享 气泡 置换</p>\n<h5 id=\"ps-内存复用如何实现内存资源的共享\"><a class=\"anchor\" href=\"#ps-内存复用如何实现内存资源的共享\">#</a> PS 内存复用如何实现内存资源的共享？</h5>\n<p>由于内存复用的目的 (提高内存的利用率，减少内存浪费，从而降低系统成本和提高系统性能。)，在于重复使用相同的内存部分，但根据不同用户的需求，会分成置换 气泡 共享等实现方式，以上三种方式分别通过将占用空间置换成空闲，将空闲未使用的内存分配给需要使用的用户，以及满足多用户可能同时读取的需求，内存复用是在不改变真实设备内存总数的基础上，提高内存资源利用率</p>\n<h5 id=\"3-全虚半虚硬件辅助区别\"><a class=\"anchor\" href=\"#3-全虚半虚硬件辅助区别\">#</a> 3 全虚 / 半虚 / 硬件辅助区别</h5>\n<h5 id=\"4-虚拟化除实现共享利用率等还能实现什么\"><a class=\"anchor\" href=\"#4-虚拟化除实现共享利用率等还能实现什么\">#</a> 4 虚拟化除实现共享，利用率等，还能实现什么</h5>\n<p>隔离性，灵活性，可靠性</p>\n<h5 id=\"5-计算虚拟化的对象\"><a class=\"anchor\" href=\"#5-计算虚拟化的对象\">#</a> 5 计算虚拟化的对象</h5>\n<h4 id=\"华为的虚拟化平台\"><a class=\"anchor\" href=\"#华为的虚拟化平台\">#</a> 华为的虚拟化平台</h4>\n<p><strong>fusion</strong> <strong>compute</strong>（计算虚拟化 / 服务器虚拟化）</p>\n<h5 id=\"fc的构成\"><a class=\"anchor\" href=\"#fc的构成\">#</a> FC 的构成：</h5>\n<p>​\t<strong>CNA</strong>：单节点管理，主要用于管理分配单个虚拟机的计算，存储，网络资源</p>\n<p>​\t<strong>VRM</strong>：集群管理，主要用于管理分配集群内的虚拟机的生命周期和资源分配统筹</p>\n<h5 id=\"虚拟机监控器\"><a class=\"anchor\" href=\"#虚拟机监控器\">#</a> 虚拟机监控器：</h5>\n<p>​\t<strong>hyper</strong>-v（Hypervisor）：作用是管理统称分配虚拟化资源 ，在虚拟化层</p>\n<h4 id=\"网络虚拟化\"><a class=\"anchor\" href=\"#网络虚拟化\">#</a> 网络虚拟化：</h4>\n<p>由于创建出虚拟机目的是为虚拟机之间能够像真实主机一样相互通信，因此需要把实际的网络资源，虚拟化后，提供给虚拟机使用</p>\n<p>虚拟机通信主要依靠虚拟交换机实现</p>\n<h5 id=\"虚拟机通信必备组件\"><a class=\"anchor\" href=\"#虚拟机通信必备组件\">#</a> 虚拟机通信必备组件:</h5>\n<p>​\t<strong>上行链路</strong>：用于连接物理交换机与虚拟交换机的实际接口，位于物理交换机上</p>\n<p>​\t<strong>端口组</strong>：用于连接虚拟机与虚拟交换机的虚拟接口，位于虚拟交换机上</p>\n<p>​\t<strong>安全组</strong>：用于保证每一个端口组内的通信安全，设置在每一个端口组中，类似于 QOS 等通信策略，并且端口组内的成员必须执行相同的安全组</p>\n<p>​\t<strong>虚拟网卡</strong>：由物理网卡通过虚拟化手段，分配给不同的虚拟机，并且在同一端口组内的虚拟机都可以分配到对应的虚拟网卡</p>\n<p>​\t<strong>vlan</strong>：用于分配端口组</p>\n<h5 id=\"虚拟机通信规则\"><a class=\"anchor\" href=\"#虚拟机通信规则\">#</a> 虚拟机通信规则：</h5>\n<ol>\n<li>若虚拟机是处于同一虚拟交换机上，且处于同一端口组内，则直接通过虚拟交换机转发流量，若处在不同端口组内，但处于同一虚拟交换机上，则需要通过上行链路转发</li>\n<li>若虚拟机处在不同交换机上，则同样需要通过上行链路转发</li>\n<li>若虚拟机 vlan 端口组相同，但处在不同虚拟交换机上，由于连接不同的上行链路，因此依旧需要物理交换机实现转发</li>\n</ol>\n<p>虚拟交换机只支持二层转发，物理交换机由于支持三层转发，因此上行链路的类型一般设置为 trunk</p>\n<p>​</p>\n<h5 id=\"虚拟机流量走向\"><a class=\"anchor\" href=\"#虚拟机流量走向\">#</a> 虚拟机流量走向</h5>\n<p><strong>东西</strong>：虚拟机之间的通信是否属于同一集群 / 数据中心内，标准看底层资源是否互通，互通则表示传递的是东西流量</p>\n<p><strong>南北</strong>：虚拟机之间的通信不属于同一数据中心内，底层资源不能互通，则传递的是南北流量</p>\n<h5 id=\"虚拟网卡类型\"><a class=\"anchor\" href=\"#虚拟网卡类型\">#</a> 虚拟网卡类型:</h5>\n<p><strong>普通网卡</strong>：通过虚拟化手段将物理网卡虚拟化后给虚拟机使用，并且对应关系是一对一，同时通过 XEN 虚拟化技术进行转发</p>\n<p><strong>直通网卡</strong>：基于物理网卡通过虚拟化手段，将实际网卡虚拟成多个虚拟网卡，然后用来对应不同的虚拟机，由于虚拟机都有自身对应的网卡，转发效率提升</p>\n<p><strong>用户态网卡</strong>：在直通网卡基础上，加快转发速度</p>\n<h4 id=\"存储资源虚拟化\"><a class=\"anchor\" href=\"#存储资源虚拟化\">#</a> 存储资源虚拟化</h4>\n<h5 id=\"存储分类\"><a class=\"anchor\" href=\"#存储分类\">#</a> 存储分类：</h5>\n<p>​\t<strong>集中式存储</strong>：现实中指将一份完整的数据，存储到一块存储设备上，若设备损 坏，则数据丢失，若以虚拟化方式进行存储，则指多个存储设备集中在某一个区域内，联合完成存储目的，可以实现一定程度的数据备份。</p>\n<p>​\t<strong>分布式存储</strong>：指可以将一份数据存放到不同的设备上，并且设备所在的位置不在同一区域。分布式存储可以更好的实现数据信息的备份</p>\n<p>​\t<strong>虚拟化存储</strong>：能够支持高级虚拟化特性，如快照，链接克隆，完整克隆，存储热迁移</p>\n<p>​\t<strong>非虚拟化存储</strong>：不支持高级虚拟化特性</p>\n<h5 id=\"存储虚拟化特性\"><a class=\"anchor\" href=\"#存储虚拟化特性\">#</a> 存储虚拟化特性：</h5>\n<p>​\t<strong>快照</strong>：作用是来备份当前状态下运行的业务，并且只能备份部分业务数据，当业务发生中断时，可通过快照功能，将其恢复到之前的某一状态下，快照并不能进行永久性的保存（当热迁移发生时，不支持迁移快照数据）</p>\n<p>​\t<strong>链接克隆</strong>：当有批量创建存储磁盘 / 虚拟机时，则可使用此方式，在链接克隆状态可以基于原始母盘，创建多个子盘，并且只需要对母盘进行统一操作即可影响子盘，创建速度快，但母盘故障，由于与子盘之间存在依附关系，则子盘失效</p>\n<p>​\t<strong>完整克隆</strong>：同样可以基于母盘进行批量创建，但与子盘之间不存在依附关系，不会因为母盘的失效而失效，创建速度慢</p>\n<p>​\t<strong>存储热迁移</strong>：在用户无感应的情况下的进行存储数据的迁移</p>\n<h5 id=\"虚拟化磁盘分类\"><a class=\"anchor\" href=\"#虚拟化磁盘分类\">#</a> 虚拟化磁盘分类：</h5>\n<p>​\t<strong>普通磁盘</strong>：会将所有空间展示给用户，并且会清空所有的空间，但用户只会使用到所需要的部分，由于需要清空所有空间，因此创建速度较慢，但性能最好</p>\n<p>​\t<strong>普通延迟置零</strong>：同样将所有空间展示给用户，但只清空用户所需要的空间，创建速度快，但性能较差</p>\n<p>​\t<strong>精简磁盘</strong>：不会将可用空间展示给用户，只会根据用户的需求发放相应存储空间，创建速度最快，但性能最差</p>\n<h5 id=\"存储资源与存储设备的关系\"><a class=\"anchor\" href=\"#存储资源与存储设备的关系\">#</a> 存储资源与存储设备的关系：</h5>\n<p>​\t<strong>存储资源</strong>：是指用来进行存储框架</p>\n<p>​\t** 存储设备:** 指不同的存储资源中可以用来进行存储的空间</p>\n<p>​\t<strong>数据存储</strong>：指用来统一管理不同存储设备中的数据信息的不同方式</p>\n<h5 id=\"基于磁盘资源分配\"><a class=\"anchor\" href=\"#基于磁盘资源分配\">#</a> 基于磁盘资源分配：</h5>\n<p>​\t<strong>普通磁盘</strong>：只能分配给一个虚拟机使用资源</p>\n<p>​\t<strong>共享磁盘</strong>：可以将分配的资源给多个虚拟机同时使用</p>\n<h4 id=\"虚拟化特性\"><a class=\"anchor\" href=\"#虚拟化特性\">#</a> 虚拟化特性:</h4>\n<p><strong>HA</strong>(<strong>高可用性</strong>) 当主机发生故障时，为避免虚拟机业务中断，被动将虚拟机迁移到集群内的其他主机上，正常运行，并且 HA 只在底层发生故障时起效，如虚拟机蓝屏 / 故障，则无法进行 HA</p>\n<p><strong>负载均衡</strong>：为提升设备性能，相对节约成本，从而不影响业务的正常运行。</p>\n<p><strong>易扩容</strong>：在不影响业务运行的过程中，若资源池资源不足，则在线进行添加</p>\n<p><strong>内容复用</strong>：提交内存的利用率，降低内存的损号，提高系统性能</p>\n<p><strong>模板部署</strong>：创建虚拟机的方式，但模板不能当虚拟机使用</p>\n<p><strong>虚拟机复制</strong>：快速创建虚拟机的方式</p>\n<p><strong>资源热添加</strong>：体现虚拟化资源易扩容的优势</p>\n<p><strong>快照</strong>：用来备份当前状态下的业务，并且只能保存部分数据，不能永久存在，当业务发生故障时，回到某一个时刻</p>\n<p><strong>numa 架构</strong>：在实现内存 CPU 共享的基础上，提升 CPU 的调用速度</p>\n<p>若需要实现以上虚拟化特性创建的虚拟机需要挂载<strong> tools</strong></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/02/20/2023.2.13/",
            "url": "http://example.com/2023/02/20/2023.2.13/",
            "title": "HCIA-security(一) 2023.2.13",
            "date_published": "2023-02-20T00:54:39.606Z",
            "content_html": "<p>传统防火墙：</p>\n<p>​\t病毒特征库 —&gt; 网咯已经出现的病毒 —&gt; 源码进行 HASH 对文件进行 HASH 计算 —&gt; 病毒特征库</p>\n<p>变种病毒：</p>\n<p>​\t已知病毒 —&gt; 源码修改 —&gt; 新的病毒（传统防火墙无法）</p>\n<p>下一代防火墙：</p>\n<p>​\t人工智能技术 / 引擎 —&gt; 对已知病毒 —&gt; 进行变种计算</p>\n<p>云 管 (网) 端  联动处理</p>\n<p>​\t安全厂商公有云平台</p>\n<p>​\t网络设备</p>\n<p>​\t终端</p>\n<p>信息安全：</p>\n<p>​\t防止任何对数据进行未授权访问的措施，或者防止造成信息有意无意泄漏、破坏、丢失等问题的发生，让数据处于远离危险、免于威胁的状态或特性。</p>\n<p>网络安全：</p>\n<p>​\t计算机网络环境下的信息安全。</p>\n<p>APT 攻击：</p>\n<p>高级持续性威胁。 利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式</p>\n<p>TCP/IP 协议栈</p>\n<p>​\t基于可信任环境开发，缺乏信息安全机制</p>\n<pre><code>1. 缺乏数据源验证机制\n2. 缺乏完整性验证机制\n3. 缺乏机密性保护机制\n</code></pre>\n<p>安全攻击基本模式：</p>\n<ol>\n<li>截获：嗅探，侦听，破坏数据的机密性</li>\n</ol>\n<p>​\t防护的措施：数据加解密技术</p>\n<ol start=\"2\">\n<li>\n<p>篡改：数据篡改，破环数据的完整性</p>\n<p>防护措施：完整性校验机制</p>\n</li>\n<li>\n<p>中断：线路破坏，Dos 拒绝服务攻击，破环数据的可用性</p>\n<p>防护措施：Anti-DDoS 设备</p>\n<p>DoS 拒绝服务攻击：占用服务器硬件资源，网络带宽。使得服务器无法为正常用户提供服务</p>\n<p>​\tTCP SYN 洪水攻击：占用服务器 TCP 资源，硬件资源</p>\n<p>​\tICMP 洪水攻击：占用服务器硬件资源，网络带宽</p>\n<p>​\tUDP 洪水攻击：占用服务器硬件资源，网络带宽</p>\n<p>DDoS 分布式拒绝服务攻击</p>\n</li>\n<li>\n<p>伪造：身份伪造，数据伪造，破坏数据真实性</p>\n<p>防护措施：身份认证技术</p>\n</li>\n</ol>\n<p>勒索病毒：</p>\n<p>​\t防护原理：在关键文件创建诱饵文件（隐藏），一旦感染加密诱饵文件，触发安全软件，隔离文件</p>\n<p>勒索病毒的过程：</p>\n<p>感染媒介 —》C&amp;C 通信 —》文件加密 —》横向移动</p>\n<p>钓鱼软件\t 匿名通信 \t混合加密体系\t弱点横向探测<br>\n蠕虫病毒 \t下载载荷\t弹出勒索对话框\t蠕虫式传播<br>\n恶意邮件\t DGA 通信\t\t\t\t\tMS17-010 永恒之蓝漏洞</p>\n<p>信息安全的五要素：</p>\n<p>保密性 —confidentiality<br>\n 完整性 —integrity<br>\n 可用性 —availability<br>\n 可控性 —controllability<br>\n 不可否认性 —Non-repudiation</p>\n<h3 id=\"防火墙基础\"><a class=\"markdownIt-Anchor\" href=\"#防火墙基础\">#</a> 防火墙基础：</h3>\n<h4 id=\"基本功能\"><a class=\"markdownIt-Anchor\" href=\"#基本功能\">#</a> 基本功能：</h4>\n<pre><code>1. 访问控制\n2. 入侵防御系统IPS（主动）   IDS 入侵检测系统（淘汰，被动）\n3. 身份认证技术\n4. VPN 远程接入\n5. 病毒查杀\n6. 文件过滤\n</code></pre>\n<h4 id=\"防火墙分类\"><a class=\"markdownIt-Anchor\" href=\"#防火墙分类\">#</a> 防火墙分类：</h4>\n<ol>\n<li>\n<p>软硬件</p>\n<p>硬件防火墙：网络安全设备</p>\n<p>软件防火墙：终端</p>\n</li>\n<li>\n<p>技术</p>\n<p>包过滤防火墙：包过滤技术 ACL</p>\n<p>应用代理防火墙：代理技术 WAF (web 应用代理防火墙)</p>\n<p>状态检测防火墙：状态检测技术</p>\n</li>\n<li>\n<p>带宽</p>\n<p>百兆防火墙，千兆防火墙，万兆防火墙</p>\n</li>\n</ol>\n<h4 id=\"防火墙发展史\"><a class=\"markdownIt-Anchor\" href=\"#防火墙发展史\">#</a> 防火墙发展史：</h4>\n<p>包过滤技术 —》应用代理技术 —》状态检测技术 —》UTM 统一威胁网关 —》下一代防火墙 NGFW</p>\n<p>​\tUTM 统一威胁网关：集成 IPS 功能，病毒检测 等功能</p>\n<p>​\t下一代防火墙 NGFW：UTM 升级版，相较于上一代防火墙性能更加强大</p>\n<p><strong>防火墙接口 / 安全区域</strong></p>\n<h5 id=\"安全区域\"><a class=\"markdownIt-Anchor\" href=\"#安全区域\">#</a> 安全区域：</h5>\n<ol>\n<li>\n<p>默认安全区域：</p>\n<p>Local 本地区域：防火墙自身</p>\n<p>Trust 信任区域：一般将内网划分为信任区域</p>\n<p>DMZ 非军事化管理区域：一般将服务器划分为 DMZ 区域</p>\n<p>Untrust 非信任区域：一般将外网划分为非信任区域</p>\n<p><strong>默认安全区域无法删除</strong></p>\n</li>\n<li>\n<p>自定义安全区域</p>\n</li>\n</ol>\n<h5 id=\"安全级别\"><a class=\"markdownIt-Anchor\" href=\"#安全级别\">#</a> 安全级别：</h5>\n<p>​\t每个区域都存在安全级别，级别唯一</p>\n<p>​\t本地：100</p>\n<p>​\tTrust：85</p>\n<p>​\tDMZ：50</p>\n<p>​\tUntrust ：5</p>\n<p>​\t<strong>默认安全区域的级别也无法修改</strong></p>\n<p>防火墙基于接口划分区域</p>\n<p>下一代防火墙 ：默认所有区域之间都不允许访问，同一个区域内部允许访问</p>\n<p>[NGFW] firewall zone 区域<br>\n [] add int g 1/0/0</p>\n<p>[] fire zone name working 设置自定义区域<br>\n [] set priority 1 设置安全级别</p>\n<h4 id=\"防火墙种类\"><a class=\"markdownIt-Anchor\" href=\"#防火墙种类\">#</a> 防火墙种类:</h4>\n<ol>\n<li>\n<p>包过滤防火墙:</p>\n<p>本质为 ACL，基于报文的特征匹配报文，对报文进行过滤</p>\n<p>通常包过滤防火墙只匹配报文的头部，不检查应用层 Data</p>\n<p><strong>缺陷</strong>：</p>\n<pre><code> 1. 无法关联数据之间的关系，制定规则时需要部署双向规则\n 2. 不检查应用层的数据\n 3. 无法使用于多通道协议\n</code></pre>\n</li>\n<li>\n<p>应用代理防火墙：</p>\n<p>核心技术：代理技术 / 中间人技术</p>\n<p>针对特定的应用 / 服务进行安全检查</p>\n<p><strong>缺陷</strong>：</p>\n<ol>\n<li>成本高，针对应用开发</li>\n<li>维护难度高，应用升级，代理防火墙也需要升级</li>\n</ol>\n<p><strong>优势:</strong></p>\n<ol>\n<li>检查应用层数据内容</li>\n</ol>\n<p>市场仅存的应用代理防火墙：WAF Web 应用代理防火墙</p>\n</li>\n<li>\n<p>状态检测防火墙：</p>\n<p>核心技术：状态检测</p>\n<p><strong>优势</strong>:</p>\n<pre><code> 1. 关联数据之间的关系，会话信息\n 2. 后续数据包处理效率高\n 3. 检测应用层数据\n</code></pre>\n<p><strong>会话表是状态检测防火墙转发的唯一的依据</strong></p>\n<p>状态防火墙收到报文后 —&gt; 判断是否转发：</p>\n<ol>\n<li>\n<p>匹配会话表 —&gt; 存在会话表 —&gt; 内容安全检查（应用层数据）—&gt; 刷新会话表 —&gt; 转发</p>\n</li>\n<li>\n<p>匹配会话表 —&gt; 不存在会话表 —&gt; 判断是否可以创建会话表</p>\n<p>创建会话表的条件：</p>\n<pre><code>1. **首包检查**   （不是首包丢弃）\n2. 路由\n3. 包过滤规则\n</code></pre>\n</li>\n</ol>\n<p>所有应用通信：</p>\n<pre><code> 1. 基于TCP    首包：SYN\n 2. **基于UDP  首包：所有的UDP报文**\n 3. 基于ICMP  首包：ICMP Echo Request\n</code></pre>\n<p>​</p>\n</li>\n</ol>\n<h4 id=\"防火墙部署\"><a class=\"markdownIt-Anchor\" href=\"#防火墙部署\">#</a> 防火墙部署：</h4>\n<ol>\n<li>\n<p>可靠性 冗余</p>\n<p>单机部署</p>\n<p>双机热备</p>\n</li>\n<li>\n<p>拓扑的位置</p>\n<p>直路部署：设备串联在网络中，对于网络影响较大</p>\n<p>旁路部署：设备旁挂在网络边缘，对网络基本无影响</p>\n</li>\n</ol>\n<pre><code>3.\t模型层次\n\n路由模式：防火墙接口工作在网络层      路由表\n\n交换模式：防火墙接口工作在数据链路层    VLAN\n</code></pre>\n<h4 id=\"防火墙安全策略\"><a class=\"markdownIt-Anchor\" href=\"#防火墙安全策略\">#</a> 防火墙安全策略：</h4>\n<ol>\n<li>包过滤过滤 —&gt;acl</li>\n<li>内容安全 —&gt; 应用数据进行病毒检测，文件过滤，邮件过滤等</li>\n</ol>\n<h5 id=\"安全策略的分类\"><a class=\"markdownIt-Anchor\" href=\"#安全策略的分类\">#</a> 安全策略的分类:</h5>\n<ol>\n<li>\n<p>域间安全策略</p>\n</li>\n<li>\n<p>域内安全策略</p>\n</li>\n<li>\n<p>接口安全策略</p>\n<p>http<br>\nhttps<br>\nping<br>\nsnmp     管理<br>\n ssh      远程登录<br>\n telnet    远程登录</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">配置客户端访问服务器</span><br><span class=\"line\">[]security-policy</span><br><span class=\"line\">[]rule name trust </span><br><span class=\"line\">  source-zone trust</span><br><span class=\"line\">  destination-zone untrust</span><br><span class=\"line\">  source-address 10.1.11.1 32</span><br><span class=\"line\">  destination-address 10.1.12.2 32</span><br><span class=\"line\">  action permit</span><br><span class=\"line\">配置同区域不能访问</span><br><span class=\"line\">[]rule name tt</span><br><span class=\"line\">  source-zone trust</span><br><span class=\"line\">  destination-zone trust</span><br><span class=\"line\">  action deny</span><br><span class=\"line\">配置ospf进入full状态</span><br><span class=\"line\">[] rule name ospf</span><br><span class=\"line\">  source-zone trust</span><br><span class=\"line\">  source-zone untrust</span><br><span class=\"line\">  destination-zone local</span><br><span class=\"line\">  service protocol 89</span><br><span class=\"line\">  action permit</span><br></pre></td></tr></table></figure>\n<p>dis  firewall session table verbose 查看会话表</p>\n<p>Current Total Sessions : 1<br>\nhttp VPN:public --&gt; public ID: a48f3648905d02c0553591da1</p>\n<p>​    协议\t防火墙自身\t\t\t区分会话<br>\n Zone: trust–&gt; local TTL: 00:20:00 Left: 00:19:56</p>\n<p>​\t区域\t\t\t老化时间\t\t剩余时间</p>\n<p>Output-interface: InLoopBack0 NextHop: 127.0.0.1 MAC: 00-00-00-00-00-00</p>\n<p>​\t数据入口<br>\n &lt;–packets:3073 bytes:3251431 --&gt;packets:2881 bytes:705651<br>\n128.18.196.4:1864–&gt;128.18.196.251:80 PolicyName: test</p>\n<h4 id=\"aspf\"><a class=\"markdownIt-Anchor\" href=\"#aspf\">#</a> ASPF</h4>\n<p>单通道协议：使用传输层一个端口的协议</p>\n<p>多通道协议：使用传输层两个或两个以上的端口的协议</p>\n<h5 id=\"ftp文件传输协议\"><a class=\"markdownIt-Anchor\" href=\"#ftp文件传输协议\">#</a> FTP：文件传输协议</h5>\n<p>C/S，客户端可以从服务器上 上传或下载文件</p>\n<p>FTP:TCP 20 数据端口：传输 FTP 数据</p>\n<p>​\tTCP 21 控制端口：协商 FTP 参数，传输模式，工作模式，认证</p>\n<p>FTP 工作模式：</p>\n<ol>\n<li>主动模式：服务器发起数据信道建立<img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcia-%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0%5Cassets%5C%E4%B8%BB%E5%8A%A8.png\" alt=\"主动\"></li>\n<li>被动模式：客户端发起数据信道建立</li>\n</ol>\n<p>、<img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcia-%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0%5Cassets%5C%E8%A2%AB%E5%8A%A8.png\" alt=\"被动\"></p>\n<p>ASPF :</p>\n<p>​\t特殊应用包过滤技术</p>\n<p>​\t作用：监听应用层数据，动态创建 / 删除 Server-map 表</p>\n<p>存在 Server-map，就会创建会话表</p>\n<p>ASPF 适用于多通道协议场景，自动创建 Server-map 对应的会话表</p>\n<p>创建 Server-map 表项的场景：</p>\n<pre><code>1. 使能ASPF,转发基于TCP的多信道协议，创建动态Server-map表\n2. 使能ASPF,转发基于UDP的多信道协议，创建动态Server-map表\n3. 配置NAT-Server，创建静态Server-map表（不会老化）\n4. 配置NAT No-Pat，创建动态server-map表\n</code></pre>\n<p>端口识别 / 端口映射：</p>\n<p>​\t转换数据包中的 D.port，将非标准端口转换成标准端口</p>\n<p>分片缓存：</p>\n<p>​\t包分片时，最后一个包分片携带网络层以上的头部，其余所有的包分片，不携带传输层 / 应用层的头部信息</p>\n<p>​\t加快数据发送的效率</p>\n<p>​\t造成：防火墙无法识别到后续包分片的端口信息</p>\n<p>将收到的包分片进行重组之后再匹配安全策略，防止前面的包分片因不携带 IP 上层头部信息导致无法匹配安全策略</p>\n<p>长连接：会话表老化时间</p>\n<p>​\t维持长时间会话表老化时间</p>\n<p>​\t针对于特殊的应用，应用需要维持长时间的通信</p>\n<p>​</p>\n<p>​\t出口网关设备：pppoe+nat + 默认路由 + 回包路由</p>\n<p>NAT 网络地址转换：</p>\n<p>​\t部署位置：一般部署再网络出口设备</p>\n<p>NAT 分类：</p>\n<p>​\tS.NAT: 转换源 IP 地址 / 源端口</p>\n<pre><code>1. 地址池模式：no-pat，pat\n2. 出接口模式：Easy-IP \n</code></pre>\n<p>​\tD.NAT: 转换目的 IP 地址 / 目的端口</p>\n<p>​\tNAT-Server（服务器映射）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">防火墙配置nat策略</span><br><span class=\"line\">nat-policy</span><br><span class=\"line\"> rule name nat</span><br><span class=\"line\">  source-zone trust</span><br><span class=\"line\">  source-zone dmz</span><br><span class=\"line\">  egress-interface GigabitEthernet1/0/2</span><br><span class=\"line\">  action nat easy-ip</span><br><span class=\"line\">   </span><br><span class=\"line\">security-policy</span><br><span class=\"line\"> rule name ospf</span><br><span class=\"line\">  source-zone trust</span><br><span class=\"line\">  destination-zone local</span><br><span class=\"line\">  service protocol 89</span><br><span class=\"line\">  action permit</span><br><span class=\"line\">  </span><br><span class=\"line\"> rule name t_ut</span><br><span class=\"line\">  source-zone trust</span><br><span class=\"line\">  source-zone dmz</span><br><span class=\"line\">  destination-zone untrust</span><br><span class=\"line\">  action permit</span><br></pre></td></tr></table></figure>\n<p>nat server fff protocol  tcp global  100.1.24.3 ftp inside 10.1.2.1 ftp</p>\n<p><strong>进行源地址转换时，先匹配安全策略，再进行地址转换</strong></p>\n<p>​\t安全策略：S.IP 私网内设备的 IP 地址</p>\n<p><strong>进行目的地址转换时</strong>，<strong>先进行地址转换</strong>，<strong>在进行安全策略匹配</strong></p>\n<p>​\t安全策略：D.IP 私网服务器的 IP 地址</p>\n<p>双向 NAT：</p>\n<p>​\tS.NAT: 转换数据包的源 IP 地址</p>\n<p>​\tD.NAT: 转换数据包的目的 IP 地址</p>\n<p>​\t双向 NAT: 同一个数据包，即转换源地址同时转换目的地址 0</p>\n<p>应用场景：实现私网内部通过公网地址访问私网内部的服务器，隐藏服务器的真实 IP 地址</p>\n<p>网络可靠性 / 冗余性</p>\n<ol>\n<li>\n<p>设备冗余：</p>\n<ol>\n<li>热备：备份的设备处于上电状态  堆叠 / 集群 / VRRP</li>\n<li>冷备：备份的设备处于下电状态</li>\n</ol>\n</li>\n<li>\n<p>端口冗余:</p>\n<p>以太网链路聚合 Eth-Trunk</p>\n<p>ppp 协议链路聚合 MP-Group</p>\n<p>HDLC 协议链路聚合 IP-Trunk</p>\n</li>\n<li>\n<p>链路冗余：</p>\n<p>拓扑设计规划</p>\n</li>\n</ol>\n<p>防火墙冗余技术：双机热备</p>\n<p>​\tvrrp 协议：实现将多个网关逻辑上虚拟为一个网关</p>\n<p>防火墙使用 VRRP 实现冗余存在的问题：</p>\n<ol>\n<li>\n<p>防火墙进行主备切换时，备份设备收到后续的流量因不存在会话表项，造成流量丢失</p>\n<p>解决：HRP 华为私有协议：防火墙之间同步状态信息和关键配置信息（会话表，Server-map ，NAT-Policy ，安全策略）</p>\n</li>\n<li>\n<p>防火墙存在多个 VRRP 组，VRRP 组内角色不一致时，导致流量来回路径不一致，如果存在接口故障，甚至会导致流量丢失</p>\n<p>解决：VGMP 协议（VRRP 组管理协议）</p>\n<p>作用：不同的 VRRP 组内保障角色的一致性</p>\n</li>\n</ol>\n<p>防火墙双机热备中使用：</p>\n<ol>\n<li>VRRP 协议 + VGMP 协议</li>\n<li>HRP 协议</li>\n</ol>\n<p>防火墙虚拟系统</p>\n<p>​\t将一台物理防火墙逻辑上虚拟为多台防火墙</p>\n<p>​\t每台防火墙之间逻辑上隔离，管理平面隔离</p>\n<p>​\t虚拟系统一般用于多租户场景，使用该技术实现每个租户单独维护和管理一个虚拟系统</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.</span><br><span class=\"line\">vsys enable </span><br><span class=\"line\">resource-class abc</span><br><span class=\"line\"> resource-item-limit session reserved-number 10 maximum 100</span><br><span class=\"line\"> resource-item-limit policy reserved-number 20</span><br><span class=\"line\"> resource-item-limit user reserved-number 3</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">vsys name A  //创建虚拟系统</span><br><span class=\"line\"> assign interface GigabitEthernet1/0/0 //关联接口</span><br><span class=\"line\"> assign interface GigabitEthernet1/0/2</span><br><span class=\"line\"> assign resource-class abc //关联资源类</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">2.为虚拟系统创建管理员</span><br><span class=\"line\">Switch vsys A </span><br><span class=\"line\">aaa</span><br><span class=\"line\">manager-user-A@@A</span><br><span class=\"line\">password cipher admin@123</span><br><span class=\"line\">service-type web</span><br><span class=\"line\">level 3</span><br><span class=\"line\"></span><br><span class=\"line\">创建虚拟系统管理员于虚拟系统配置IP，路由，安全策略，NAT</span><br><span class=\"line\">switch vsys A</span><br><span class=\"line\"> </span><br><span class=\"line\">4.虚拟系统之间互访</span><br><span class=\"line\">4.1创建VLF区域</span><br><span class=\"line\">firewall zone name VIF id 4</span><br><span class=\"line\"> set priority 1</span><br><span class=\"line\"> add interface Virtual-if1</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">rule name T_VLF //创建安全策略t访问VLF</span><br><span class=\"line\">  source-zone trust</span><br><span class=\"line\">  destination-zone VIF</span><br><span class=\"line\">  action permit</span><br><span class=\"line\">4.2配置虚拟系统之间访问的路由</span><br><span class=\"line\"></span><br><span class=\"line\">4.3配置虚拟地址之间的安全策略</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n<p>VPN 概述：</p>\n<p>​\t二级 ISP 搭建 VPN 网络：MPLS VPN</p>\n<p>​\t企业自建 VPN 网络：IPSec，L2TP ,GRE,SSL</p>\n<p>​</p>\n<p>VPN 定义：</p>\n<p>​\t再 ISP 基础上构建一条逻辑上的专线（隧道）</p>\n<p>VPN 分类：</p>\n<p>​\t按照业务类型</p>\n<ol>\n<li>\n<p>Accsee VPN/Client-LAN VPN</p>\n<p>适用于远程办公，居家办公接入公司内网的场景</p>\n</li>\n<li>\n<p>LAN-LAN VPN</p>\n<p>一个局域网通过 VPN 接入到另一个局域网</p>\n<p>适用于总部分支通信的场景</p>\n</li>\n</ol>\n<p>​\t按网络层次：</p>\n<p>​\t应用层： SSL VPN</p>\n<p>​\t网络层：IPSec VPN ,GRE VPN</p>\n<p>​\t网络接口层 ： L2TP</p>\n<p>​</p>\n<table>\n<thead>\n<tr>\n<th><strong>隧道协议</strong></th>\n<th><strong>保护范围</strong></th>\n<th><strong>使用场景</strong></th>\n<th><strong>用户身份认证</strong></th>\n<th><strong>加密和验证</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GRE</td>\n<td>IP 层及以上数据</td>\n<td>Intranet VPN</td>\n<td>不支持</td>\n<td>支持简单的关键字验证、校验</td>\n</tr>\n<tr>\n<td>L2TP</td>\n<td>IP 层及以上数据</td>\n<td>Access VPN         Extranet VPN</td>\n<td>支持基于 PPP 的 CHAP、PAP、EAP 认证</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>IPSec</td>\n<td>IP 层及以上数据</td>\n<td>Intranet VPN             Access VPN                                                                 Extranet VPN</td>\n<td>支持预共享密钥或证书认证、支持 IKEv2 的 EAP 认证</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>SSL VPN</td>\n<td>应用层特定数据</td>\n<td>Access VPN</td>\n<td>支持多种身份认证</td>\n<td>支持</td>\n</tr>\n</tbody>\n</table>\n<p>VPN 核心技术：</p>\n<ol>\n<li>\n<p>隧道技术</p>\n</li>\n<li>\n<p>加解密技术</p>\n<p>​\t古典加密学：算法保密，密钥保密</p>\n<p>​\t近代加密学：算法公开，密钥保密</p>\n<p>​\t现代加密学：算法公开，密钥公开</p>\n<p>主流的加解密算法：</p>\n<ol>\n<li>\n<p>对称加密算法</p>\n<p>缺陷：</p>\n<ol>\n<li>密钥传输存在风险</li>\n<li>密钥数量多，难以管理</li>\n</ol>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcia-%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0%5Cassets%5C1676600668432.png\" alt=\"1676600668432\"></p>\n</li>\n<li>\n<p>非对称加密算法</p>\n<p>维护两个密钥：公钥，私钥</p>\n<p>公钥公开，私钥保密</p>\n<p>使用公钥加密，只能使用私钥解密：数据加解密</p>\n<p>使用私钥加密，只能使用公钥解码：数字签名</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcia-%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0%5Cassets%5C1676601799431.png\" alt=\"1676601799431\"></p>\n<p>​\t数据加解密场景：</p>\n<p>​\t数据加解密时，使用对称加密算法</p>\n<p>​\t传输对称加密算法的密钥时，使用非对称加密算法进行加密传递</p>\n<ol start=\"3\">\n<li>\n<p>身份认证技术：</p>\n<p>数字证书：</p>\n<p>被颁发者的身份信息</p>\n<p>被颁发者的公钥信息</p>\n<p>颁发者的身份信息</p>\n</li>\n</ol>\n<p>数据传输安全案例:</p>\n<ol>\n<li>A 的原始信息通过 HASH 算法形成<strong>信息摘要</strong></li>\n<li>然后用 A 自己的私钥和信息摘要形成<strong>数字签名</strong></li>\n<li>然后用 A 和 B 之间的<strong>对称加密密钥</strong>进行对 A 的原始信息，数字签名，A 的证书 加密形成<strong>加密信息</strong></li>\n<li>然后用 B 的公钥对称加密形成<strong>密钥信封</strong></li>\n<li>然后 B 收到后密钥信封后用 B 的私钥对称解密得到 对称加密密钥</li>\n<li>然后 B 用对称加密密钥 对加密信息进行解密 得到原始信息，数字签名，A 的证书</li>\n<li>从 A 的证书中得到 A 的公钥</li>\n<li>然后 B 用 A 的公钥验证数字签名 得到信息摘要</li>\n<li>B 对原始信息进行 HASH 算法形成信息摘要</li>\n<li>进行对比</li>\n</ol>\n<p>IPSec VPN</p>\n<pre><code>1. 企业自建VPN \n2. IPSec开发协议簇，包含AH协议,ESP协议，IKE协议\n3. IPSec支持IPv4和IPv6\n4. IPSec属于网络层VPN ,通过隧道封装（插入新头部）保护网络层及以上的数据部分\n</code></pre>\n<p>IPSec 工作模式:</p>\n<ol>\n<li>\n<p>传输模式</p>\n<p>​\t使用于主机和主机之间端到端通信保护</p>\n<p>​\t隧道封装：在原始数据包 IP 头部后插入 IPSec 头部</p>\n<p>​\t原始数据包：IP 头 \tData</p>\n<p>​\t隧道封装后：IP 头\tIPSec\tData</p>\n<p>​</p>\n</li>\n<li>\n<p>隧道模式</p>\n<p>​\t适用于私网和私网之间通信保护</p>\n<p>​\t隧道封装：在原始数据包前新增新的 IP 头和 IPSec 头部</p>\n<p>​\t原始数据包：IP 头\tData</p>\n<p>​\t隧道封装后：新 IP 头\tIPSec \tIP 头\tData</p>\n</li>\n</ol>\n<p>通信保护协议</p>\n<ol>\n<li>\n<p>AH 协议 鉴别头协议 / 认证报头协议 50</p>\n<p>安全功能：</p>\n<pre><code> 1. 完整性校验：哈希算法计算摘要值\n 2. 数据源鉴别：共享密钥\n 3. 防重放攻击：序列号\n</code></pre>\n</li>\n</ol>\n<p>AH 协议在传输模式下封装：</p>\n<p>​\t原始数据包：IP 头 \tData</p>\n<p>​\t对整个数据包进行 hash 计算，摘要值填充到 AH 头部中</p>\n<p>​\t隧道封装后：IP 头 \tAH 头\tData</p>\n<p>AH 在隧道模式下封装：</p>\n<p>​\t原始数据包：IP 头\tData</p>\n<p>​\t添加新 IP 头：新 IP 头\tIP 头\tdata</p>\n<p>​\t对整个数据包进行 hash 计算，包含新的 IP 头</p>\n<p>​\t隧道封装后：新 IP 头\tAH 头\t原始 IP 头\tData</p>\n<p><strong>AH 协议在进行完整性计算时，包含了最外层 IP</strong> 头部（）整个数据包</p>\n<p>2.ESP 协议 封装安全净载协议 50</p>\n<p>​\t安全功能：</p>\n<ol>\n<li>完整性校验</li>\n<li>数据源鉴别</li>\n<li>防重传攻击</li>\n<li>数据加解密</li>\n</ol>\n<p>ESP 在传输模式下封装：</p>\n<p>​\t原始数据包：IP 头\tData</p>\n<p>​\t隧道封装后：IP 头\tIPSec 头\tData\tIPSec 尾部</p>\n<p>​\t对 Data 和 IPSec 尾部进行加密：IP 头部\tIPsec 头 \t加密（Data ipsec 尾部）</p>\n<p>​\t对 IPsec 头部和加密部分进行校验：IP 头\tIPsec 头\t加密\tIPSec 认证</p>\n<p>ESP 在隧道模式下封装：</p>\n<p>​\t原始数据包：IP 头\tData</p>\n<p>​\t隧道封装后：新的 IP 头\tIPsec 头\tip 头\tdata\tipsec 尾部</p>\n<p>​\t对原始整个数据包和尾部进行加密：新 ip 头\tIPsec 头\t加密（IP 头\tData\tIPsec 尾部）</p>\n<p>​\t对 IPsec 头部和加密部分进行校验：新 IP 头\tIPsec 头\t加密\tIPSec 认证</p>\n<p>ESP 加密部分：</p>\n<p>传输模式，加密 Data IPSec 尾部</p>\n<p>隧道模式，加密整个原始数据包和 IPsec 尾部</p>\n<p>ESP 校验部分：</p>\n<p>传输模式，校验 ESP 头部和加密数据（Data IPSEC 尾部）</p>\n<p>隧道模式，校验 ESP 头部和加密部分（原始数据包，IPsec 尾部）</p>\n<p>ESP 校验不包含最外层 IP 头</p>\n<table>\n<thead>\n<tr>\n<th><strong>安全特性</strong></th>\n<th><strong>AH</strong></th>\n<th><strong>ESP</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>协议号</strong></td>\n<td>51</td>\n<td>50</td>\n</tr>\n<tr>\n<td><strong>数据完整性校验</strong></td>\n<td>支持</td>\n<td>支持（不验证 IP 头）</td>\n</tr>\n<tr>\n<td><strong>数据源验证</strong></td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td><strong>数据加解密</strong></td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td><strong>抗重放服务</strong></td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td><strong>NAT-T</strong>**（<strong><strong>NAT</strong></strong> 穿越）**</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n</tbody>\n</table>\n<p>IPsec 建立：</p>\n<ol>\n<li>\n<p>建立 IPsec 安全联盟</p>\n<ol>\n<li>\n<p>手工建立安全联盟</p>\n</li>\n<li>\n<p>IKE 协议动态建立安全联盟</p>\n<p>IKE 工作工程：</p>\n<ol>\n<li>\n<p>建立 IKE SA：建立临时的经过身份认证的保密的通道</p>\n<p>ipsec 的 ike 协商用端口 udp500 和 udp4500</p>\n<p>​\t核心任务：</p>\n<ol>\n<li>协商 IKE SA 参数</li>\n<li>密钥交换</li>\n<li>身份认证</li>\n</ol>\n<p>​\t主模式：</p>\n<ol>\n<li>使用出口地址作为身份标识</li>\n<li>交互 6 个消息，后两个消息被保护</li>\n<li>身份认证过程被加密保护</li>\n</ol>\n<p>​\t野蛮模式：</p>\n<ol>\n<li>使用用户名字符串，IP 地址等作为身份标识</li>\n<li>交互三个消息，只有最后一个消息被保护</li>\n<li>不保护对端的身份标识</li>\n</ol>\n</li>\n<li>\n<p>建立 IPSec SA  ：建立 IPsec 数据保护的真正通道</p>\n<p>核心：协商 IPsec 安全参数</p>\n<p>​\t加密算法<br>\n​\tHash 算法<br>\n​\t安全协议<br>\n​\t工作模式<br>\n​\t存活时间</p>\n<p>模式：快速模式</p>\n<p>​</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><strong>主模式</strong></th>\n<th><strong>野蛮模式</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>消息交互</strong></td>\n<td>交互 6 个消息</td>\n<td>交互 3 个消息</td>\n</tr>\n<tr>\n<td><strong>身份 ****ID</strong></td>\n<td>以 IP 地址作为身份 ID，自动生成本端身份 ID 和对端身份 ID</td>\n<td>可以以多种形式（IP，字符串等）手动或自动的生成本端和对端的身份 ID</td>\n</tr>\n<tr>\n<td><strong>预共享密钥</strong></td>\n<td>只能基于 IP 地址来确定预共享密钥。</td>\n<td>基于 ID 信息（主机名和 IP 地址）来确定预共享密钥。</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td><strong>较高</strong>前 4 个消息以明文传输，最后两个消息加密，对对端身份进行了保护</td>\n<td><strong>较低</strong>前两个消息以明文传输，最后一个消息进行加密，不保护对端身份</td>\n</tr>\n<tr>\n<td><strong>速度</strong></td>\n<td>较慢</td>\n<td>较快</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ol>\n</li>\n<li>\n<p>IPsec 数据传输</p>\n</li>\n</ol>\n<p>SA 安全联盟：</p>\n<p>​\tvpn 网关设备之间参数约定</p>\n<p>​\tSA 由三元组唯一标识：安全参数索引（SPI） 目的 IP 地址\t安全协议号</p>\n<p>NAT-T 场景下：</p>\n<p>​\tIPsec VPN：</p>\n<p>​\t隧道模式，ESP 协议，野蛮模式</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/01/24/2022.12.9/",
            "url": "http://example.com/2023/01/24/2022.12.9/",
            "title": "HCIP(十八） 2022.12.9",
            "date_published": "2023-01-24T04:30:55.844Z",
            "content_html": "<h4 id=\"bfd\"><a class=\"markdownIt-Anchor\" href=\"#bfd\">#</a> BFD：</h4>\n<p>​\t双向转发检测，是一个介质无关，协议无关的故障检测协议，应用广泛，能够再毫秒级别感应到网络故障问题</p>\n<p>注：BFD 通过在设备之间建立会话，互相交互 BFD 报文来检测两者之间的连通性问题</p>\n<h5 id=\"bfd会话建立方式\"><a class=\"markdownIt-Anchor\" href=\"#bfd会话建立方式\">#</a> BFD 会话建立方式：</h5>\n<p>​\t静态建立 BFD 会话：管理员手工配置本地标识符和远端标识符（标识符用于区分本地会话）</p>\n<p>​\t动态建立 BFD 会话：标识符由系统自动分配</p>\n<h5 id=\"bfd的状态变化\"><a class=\"markdownIt-Anchor\" href=\"#bfd的状态变化\">#</a> BFD 的状态变化：</h5>\n<p>​\tDown：建立 BFD 会话的初始状态 / 会话 Down</p>\n<p>​\tinit：处于 Down 状态时收到了 Down 状态 BFD 报文进入 init 状态</p>\n<p>​\tUP：处于 init 状态时收到了 init/UP 状态的报文进入 UP 状态，表示 BFD 会话建立完成</p>\n<p>​\tAdminDown：管理员 Down，由管理员手工将会话 Down，不是因为网络故障</p>\n<p>注：在任何一个状态，只要会话超时就会回到 Down 状态，此时认为网络故障</p>\n<h5 id=\"bfd的检测模式\"><a class=\"markdownIt-Anchor\" href=\"#bfd的检测模式\">#</a> BFD 的检测模式：</h5>\n<p>​\t异步模式：两个设备都支持 BFD，互相交互 BFD 报文，设备通过是否能够接收到对端发送的 BFD 报文来判断会话连接状态（连通性）</p>\n<p>​\t查询模式：只有一端开启 / 支持 BFD，通过是否能够接收到自己发送出去的 BFD 报文判断连通性</p>\n<h5 id=\"bfd检测时间\"><a class=\"markdownIt-Anchor\" href=\"#bfd检测时间\">#</a> BFD 检测时间：</h5>\n<p>​\tTX：发送时间间隔</p>\n<p>​\tRX：接收时间间隔</p>\n<p>​\tDM：检测倍数</p>\n<p>​\t设备实际发送时间间隔 = MAX (本地配置发送时间间隔，对端配置接收时间间隔)</p>\n<p>​\t设备实际接收时间间隔 = MAX (对端配置发送时间间隔，本地配置接收时间间隔)</p>\n<p>​</p>\n<h6 id=\"实际检测时间\"><a class=\"markdownIt-Anchor\" href=\"#实际检测时间\">#</a> 实际检测时间：</h6>\n<p>​\t异步模式 = 设备实际接收时间间隔 * 对端配置检测倍数</p>\n<p>​\t查询模式 = 设备实际接收时间间隔 * 本地配置检测倍数</p>\n<p>静态 BFD</p>\n<pre><code>1. bfd //开启BFD\n2. bfd 1 bind peer-ip *  source-ip * //创建BFD会话\n3. discriminator  local  *  //设置本地标识符\n4. discriminator  remote  * //设置远端标识符\n5. commit  //启动配置 \n</code></pre>\n<p>动态 BFD</p>\n<ol>\n<li>bfd // 开启 BFD</li>\n<li>bfd 1 bind peer-ip *  source-ip *  auto // 创建 BFD 会话</li>\n</ol>\n<h5 id=\"bfd-echo\"><a class=\"markdownIt-Anchor\" href=\"#bfd-echo\">#</a> BFD Echo：</h5>\n<p>BFD 单臂回声，当进行 BDF 检测时，有一端不支持 BFD 功能，此时可以通过回声达到检测的目的（设备发送 BFD 报文封装源目 IP 地址都为自己的地址，对端接收到后根据目的 IP 转发回来）</p>\n<p>配置:</p>\n<p>​\tbfd 1 bind peer-ip 10.1.12.2 interface g0/0/0 one-arm-echo</p>\n<p>​\tdiscriminator local 100</p>\n<p>​\tcommit</p>\n<h5 id=\"静态路由与bfd联动\"><a class=\"markdownIt-Anchor\" href=\"#静态路由与bfd联动\">#</a> 静态路由与 BFD 联动：</h5>\n<p>​</p>\n<p>1. 建立静态路由的主备份路径：</p>\n<p>（r1）ip route-static 10.1.45.0 255.255.255.0 10.1.34.4<br>\n（r3）ip route-static 10.1.45.0 255.255.255.0 10.1.35.5 preference 70</p>\n<p>2. 在静态主路径上与 BFD 进行联动</p>\n<p>（r1）bfd 1 bind peer-ip 10.1.34.4 source-ip 10.1.34.3 auto</p>\n<p>（r2）bfd 1 bind peer-ip 10.1.34.3 source-ip 10.1.34.4 auto</p>\n<p>3. 将静态主路径上与 BFD 进行联动</p>\n<p>（r1）ip route-static 10.1.45.0 255.255.255.0 10.1.34.4 track bfd-session 1</p>\n<p>修改 BFD 时间间隔：</p>\n<ol>\n<li>detect-multiplier 5 // 修改检测倍数</li>\n<li>min-tx-interval 500 // 修改发送报文时间</li>\n<li>min-rx-interval 500 // 修改接收报文时间</li>\n</ol>\n<h5 id=\"ospf与bfd联动\"><a class=\"markdownIt-Anchor\" href=\"#ospf与bfd联动\">#</a> OSPF 与 BFD 联动</h5>\n<p>在 OSPF 进程下：</p>\n<p>bfd all-interfaces enable  // 开启所有 OSPF 接口的 BFD 检测功能</p>\n<p>bfd all-interfaces min-tx-interval</p>\n<p>bfd all-interfaces min-rx-interval</p>\n<p>bfd all-interfaces  detect-multiplier</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/01/24/2022.12.8/",
            "url": "http://example.com/2023/01/24/2022.12.8/",
            "title": "HCIP(十七） 2022.12.8",
            "date_published": "2023-01-24T04:30:55.842Z",
            "content_html": "<h5 id=\"pim-sm\"><a class=\"markdownIt-Anchor\" href=\"#pim-sm\">#</a> PIM SM：</h5>\n<p>​\tPIM Sparse Mode，稀疏模式，PIM SM 认为网络中不存在一个接收者，采用拉（pull）的形式</p>\n<h6 id=\"组播分发树\"><a class=\"markdownIt-Anchor\" href=\"#组播分发树\">#</a> 组播分发树：</h6>\n<p>​\tSPT：最短路径树，通过（S,G）表项构建</p>\n<p>​\tRPT：共享树（汇聚点树），通过（*，G）表项构建</p>\n<p>注：RP：汇聚点，类似信息汇聚中心，拥有所有组播源和组播组接收者的信息，所有组播路由都知道 RP 的位置，可以静态指定，也可以动态选举</p>\n<p>组播源侧 DR：负责向 RP 发送单播注册消息</p>\n<p>接收者侧 DR：负责向 RP 发送 Join 加入消息（查询器角色）</p>\n<p>DR 选举与 PIM DM 相同</p>\n<p>**PIM-SM(ASM)**<strong> 协议报文</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>报文类型</strong></th>\n<th><strong>报文功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Hello</td>\n<td>用于 PIM 邻居发现，协议参数协商，PIM 邻居关系维护等</td>\n</tr>\n<tr>\n<td>Register（注册）</td>\n<td>用于事先源的注册过程。这是一种单播报文，在源的注册过程中，组播数据被第一跳路由器封装在单播注册报文中发往 RP</td>\n</tr>\n<tr>\n<td>Register-Stop（注册停止）</td>\n<td>RP 使用该报文通知第一跳路由器停止通过注册报文发送组播流量</td>\n</tr>\n<tr>\n<td>Join/Prune（加入 / 剪枝）</td>\n<td>加入报文用于加入组播分发树，剪枝则用于修剪组播分发树</td>\n</tr>\n<tr>\n<td>Assert（断言）</td>\n<td>用于断言机制</td>\n</tr>\n<tr>\n<td>Bootstrap（自举）</td>\n<td>用于 BSR 选举。另外 BSR 也使用该报文向网络中扩散 C-RP（Candidate-RP，候选 RP）的汇总信息</td>\n</tr>\n<tr>\n<td>Candidate-RP-Advertisement   （候选 RP 通告）</td>\n<td>C-RP 使用该报文向 BSR 发送通告，报文中包含该 C-RP 的 IP 地址及优先级等信息</td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"pim-sm-再asm模型下的工作过程\"><a class=\"markdownIt-Anchor\" href=\"#pim-sm-再asm模型下的工作过程\">#</a> PIM SM 再 ASM 模型下的工作过程：</h6>\n<ol>\n<li>接收者侧 DR 通过和接收者之间运行 IGMP 协议可以得知有哪些组播组的接收者，然后主动朝着 RP 的方向发送 Join 加入报文，沿途所有路由器都会形成（*，G）表项，并且将收到 Join 加入报文的端口作为下游端口，一直到 RP 构建 RPT</li>\n<li>组播源侧 DR 在收到第一个组播报文时，会将组播报文封装为单播注册报文发送给 RP，RP 收到注册报文后，通过注册报文中的组播数据找到组播源和组播组信息，然后反向发送 Join 加入消息，沿途所有路由器形成（S,G）表项，并将收到 JOIN 报文的端口作为下游接口，直到组播源构建 SPT ,</li>\n<li>由于组播源侧 DR 形成（S,G）表项后组播数据可以转发，注册报文又会单播发送，造成重复数据的问题，此时 RP 会再向组播源册 DR 发送注册停止报文（Rejister-stop），组播源侧 DR 收到停止报文后不再发送注册报文，组播数据正常转发</li>\n</ol>\n<p>注 SPT 和 RPT 树构建完成后，组播数据首先没有沿着 SPT 树转发至 RP，再沿着 RPT 树转发至接收者</p>\n<h6 id=\"spt切换\"><a class=\"markdownIt-Anchor\" href=\"#spt切换\">#</a> SPT 切换：</h6>\n<p>​\t当组播接收者侧 DR 收到的组播数据不是最优的，触发切换 SPT，通过组播数据中携带的组播源信息，反向朝着组播源的方向发送 Join 加入消息，构建 SPT 树，沿途所有路由器形成（S,G）表项，并将收到报文的端口作为下游接口，之后的组播数据可以沿着新构建的 SPT 转发，组播源侧 DR 会向原先构建的 RPT 剪枝（向 RP 剪枝），为了维持 SPT 和剪枝状态，接收者侧 DR 会周期性 60s 发送 Join 加入报文和 Prune 剪枝报文（如果是共享网段也会触发断言机制竞选，避免重复数据）</p>\n<p>​</p>\n<h6 id=\"pim-sm-再ssm模型下的工作过程\"><a class=\"markdownIt-Anchor\" href=\"#pim-sm-再ssm模型下的工作过程\">#</a> PIM SM 再 SSM 模型下的工作过程：</h6>\n<p>​\t对于成员端 DR 来说，与接收者之间运行了 IGMPv3，能够得知接收者需要哪些组播源的组播数据，可以主动向组播源的方向发送 join 加入报文，反向建立 SPT，沿途所有路由器生成 (S,G) 表项，并将收到 Join 报文的端口作为下游接口，直到源端 DR，后续的组播数据都沿着 SPT 转发至接收者</p>\n<p>注：SSM 模型下，不需要 RP，无需构建 RPT 以及注册源</p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1670469599101.png\" alt=\"1670469599101\"></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/01/24/2022.12.16/",
            "url": "http://example.com/2023/01/24/2022.12.16/",
            "title": "HCIP(二十三) 2022.12.16",
            "date_published": "2023-01-24T04:30:55.839Z",
            "content_html": "<h4 id=\"mpls-vpn\"><a class=\"markdownIt-Anchor\" href=\"#mpls-vpn\">#</a> MPLS VPN :</h4>\n<p>​\tVPN：</p>\n<p>虚拟专用网络</p>\n<h5 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\">#</a> 背景：</h5>\n<pre><code>1. 直接通过公网通信安全性过低\n2. 搭建物理专线安全性高，但是成本也相应增多\n</code></pre>\n<p>PE：运营商边缘设备</p>\n<p>P：运营商核心设备</p>\n<p>CE：用户边缘设备</p>\n<h5 id=\"vpf\"><a class=\"markdownIt-Anchor\" href=\"#vpf\">#</a> VPF:</h5>\n<p>虚拟路由转发，类似虚拟路由表，用于 PE 本地区分不同客户的路由（不同客户可能存在地址空间重叠的问题），只在本地有效</p>\n<h5 id=\"rd\"><a class=\"markdownIt-Anchor\" href=\"#rd\">#</a> RD：</h5>\n<p>路由标识符，8 字节，用于 PE 之间传递路由时进行区分，普通的 IPv4 路由加上 RD 值后就是 VPN-IPv4 路由，简称 VPNv4 路由，长 12 字节</p>\n<h5 id=\"rt\"><a class=\"markdownIt-Anchor\" href=\"#rt\">#</a> RT:</h5>\n<p>分为 Export-RT 和 Import-RT（出方向 RT 和入方向 RT），出方向 RT 值作为 MP-BGP 的扩展团体属性携带在路由中，入方向 RT 值用于检查收到的路由是否可以接收</p>\n<p><strong>注：MP-BGP：BGP 的多协议扩展，普通的 BGP-4 无法传递 VPNv4 路由，需要使能地址族 VPNv4 功能，也就是 MP-BGP，使其能够传递 VPNv4 路由</strong></p>\n<h5 id=\"vpn的路由传递\"><a class=\"markdownIt-Anchor\" href=\"#vpn的路由传递\">#</a> VPN 的路由传递：</h5>\n<pre><code>1. 本端CE——&gt;本端PE: 通过路由协议\n2. 本端PE——&gt;对端PE：通过MP-BGP\n3. 对端PE——&gt;对端CE：同上\n</code></pre>\n<h5 id=\"vpn的报文转发\"><a class=\"markdownIt-Anchor\" href=\"#vpn的报文转发\">#</a> VPN 的报文转发：</h5>\n<pre><code>1. 数据从PE设备转发至P设备时，P设备没有路由无法转发，需要在公网设置LDP隧道，分配公网标签\n2. 数据从PE1-PE2时，PE无法判断查找那个路由表，需要MP-BGP 为私网路由分配私网标签进行区分\n</code></pre>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1671180735844.png\" alt=\"1671180735844\"></p>\n<p>VPN 路由的传递过程：</p>\n<p>CE1——PE1——P——PE2——CE2</p>\n<ol>\n<li>CE1-PE1 之间运行了路由协议，并且 PE1 运行协议时绑定了 VPN 实例，所以 CE1 的路由可以传递到 PE1 的 VRF 中</li>\n<li>PE1 与 PE2 之间建立了 MP-BGP 的 IBGP 对等体关系，将 CE1-PE1 之间的路由协议引入 BGP 中，PE2 就可以学习到 CE1 的路由，并且携带了出方向的 RT 值（作为 BGP 的扩展团体属性），MP-BGP 为该路由分配了一个私网标签（发布给 PE2 作为出标签）</li>\n<li>PE2-CE2 之间也运行了路由协议，将 BGP 引入 PE2-CE2 路由协议中，CE2 就可以学习到 CE1 的路由</li>\n</ol>\n<p>数据转发过程：</p>\n<p>CE2———&gt;CE1</p>\n<ol>\n<li>CE2 想要访问 CE1, 封装数据查找 FIB，下一跳为 PE2, 将数据发送给 PE2</li>\n<li>PE2 收到数据后通过查找 CE2 对应的 VRF 转发表，发现去往 CE2 需要进行标签转发，加上一个私网标签，然后去往 CE1 的下一跳为 PE1, 非直连，再查找去往 PE1 的转发表，发现又需要进行标签转发，加上一层公网标签，从对应的接口发送给下一跳设备（P 设备）</li>\n<li>P 设备收到数据后，看到最外层的公网标签，根据入标签找到对应的出标签，执行交换标签的动作（公网标签），从对应的接口发送给下一跳</li>\n<li>PE1 收到数据后，外层公网标签没有对应的出标签，拆掉公网标签，查看内层私网标签，发现是给 CE1 路由分配的，没有对应的出标签，拆掉私网标签，查找 CE1 对应的 VRF1 转发表，发送给 CE1 设备</li>\n</ol>\n<h4 id=\"vpn组网\"><a class=\"markdownIt-Anchor\" href=\"#vpn组网\">#</a> VPN 组网：</h4>\n<p>​\tIntranet：相同 VPN 用户之间互访，不同 VPN 用户相互隔离</p>\n<p>​\tExtranet：一个 VPN 用户可以与不同 VPN 用户互访</p>\n<p>​\tHub-Spoke：Spoke 之间访问需要通过 Hub（例如分公司之间通信经过总公司）</p>\n<p>CE1(AS100)——PE1—P—PE2(AS 123)——CE2(AS 100)</p>\n<p>CE1 和 CE2 属于同一个 VPN 用户，AS 号相同，当 PE-CE 之间运行的都是 BGP 协议时，PE 将路由传递给 CE 设备，会由于 AS_Path 中包含自身 AS 号不接收 VPN 路由，导致路由传递失败</p>\n<p>注：开启 PE 设备上针对对等体的 AS 号替换功能，将其中的 AS 号替换为本地 AS 号（原本 PE 传递的路由 AS_Path 为 123，100；替换后为 123，123）</p>\n<p>So0 属性：</p>\n<p>​\t开启 PE 设备的 AS 号替换功能后，在一些特殊场景下可能会导致路由环路（一个 PE 连接了同一个站点的多个 CE, 并且都建立 EBGP）, 此时可以设置 PE 针对这两个 CE 的相同 So0 值，当 PE 从 CE1 学习到路由后，给路由加上设置的 So0 属性，再传递给另一个 CE 时检查路由携带的 So0 属性与要传递 CE 设置的 So0 属性是否一致，一致则不传递</p>\n<p>DomainID，Route Type ：通过 BGP 的扩展团体属性携带，两端 CE-PE 都运行 OSPF 时，如果接收到的路由 DomianID 与本地一致，表示属于同一个 OSPF 域，原本的 Route Type 为 1，2，3——3 ，原本 5，7—5，7；如果 DomianID 不一致，原本 1，2，3，5，7——5，7</p>\n<p>Type-3 防环：PE 将路由传递给 OSPF 实例邻居时，将 LSA 中 Option 的 DN 为置位 1，其他 PE 设备收到 DN 置位 1 的路由不进行计算</p>\n<p>Type-5/7 防环：PE 在将路由传递给 OSPF 实例邻居时 LSA 中携带 Route Tag（默认为本地 AS 计算得出）, 其他 PE 收到 Route Tag 数值与本地计算得出的一致则不进行计算</p>\n<p>后门链路：在两端 CE 之间建立后门链路作为 VPN 备份，互相传递路由，如果 CE-PE 协议为 OSPF , 导致后门链路传递的路由为 OSPF 域内路由，VPN 传递的为域间路由（type3），后门链路会被优选，没有达到作为备份的目的</p>\n<p>Sham Link：在 PE 设备之间建立一条伪链路，使 VPN 传递的路由也成为 OSPF 域内，再将后门链路的开销设置比 Sham link 大，则可以使后门链路成为备份链路</p>\n<p>ISIS 快速收敛；</p>\n<p>​\tI-SPF; 增量最短路劲优先算法，只计算发送变化的节点信息</p>\n<p>​\tISIS 的分片扩展，正常情况下，一个 ISIS 路由器的 LSP 可以最多生成 256 个分片携带信息，可以携带的数据有限</p>\n<p>​\t分片扩展，一个 ISIS 设备可以设置多个虚拟路由器（最多 50 个），每一个虚拟路由器可以产生自己的 LSP（可以携带 256 个分片），所以扩展后可携带分片数为 50*256 个</p>\n<p>​\t初始系统，物理路由器</p>\n<p>​\t系统 ID，物理路由器的系统 ID</p>\n<p>​\t虚拟系统，虚拟路由器</p>\n<p>​\t附加系统 ID，虚拟路由器的系统 ID</p>\n<p>​\t分配扩展模式，</p>\n<p>​\tMode-1，邻居路由器不支持分片扩展，将虚拟系统作为真实设备和原设备分开进行计算</p>\n<p>​\tMode-2，邻居路由器支持分片扩展，能够得知虚拟系统的初始系统是原设备，将数据集中统一计算</p>\n<p>BGP 高级特性，</p>\n<p>​\t路由控制，</p>\n<p>​\t正则表达式，（特殊字符含义）</p>\n<p>​\tAS-path Filter，路劲信息过滤器，针对 BGP 路由中携带了 AS_Path 属性对路由进行控制，AS_PATH Filter 可以通过正则表达式匹配路由 AS_Path 字符串）</p>\n<p>例如 10.1.1.1/32 携带 AS_Path 103 102 101</p>\n<p>​\t通过 AS_Path Filter 匹配时，</p>\n<p>​\tIP AS_Path Filter 1 permit /deny ^103/101$ 等</p>\n<p>注 AS_Path Filter 可以直接针对对等体应用，也可以结合 ROuter-POlicy 使用</p>\n<p>​\tCommunity Filter，团体属性过滤器，针对 BGP 路由中携带的团体属性进行控制</p>\n<p>​\t分类，</p>\n<p>​\t基本 Community Filter ，编号 1-99，可以匹配路由中的团体号 / 公认团体属性（传递范围）</p>\n<p>​\t高级 Community Filter， 编号 100-199，可以通过正则表达式对路由的团体属性进行匹配</p>\n<p>​\t注 BGP 路由器默认不向对等体通过团体属性，可以通过 Peer 对等体 IP Advertise-Community 命令开启</p>\n<p>结合 ROute-policy 使用</p>\n<p>BGP 其他特性，</p>\n<p>​\tORF，出口路由过滤器，BGP 设备只期望接收对等体发送自己某些路由，可以配置策略，然后通过 ORF 报文发送给对等体，对等体接收到 ORF 报文后策略只发布满足条件的路由</p>\n<p>​\t对等体组，将某些具有相同特性的对等体放入同一个对等体组，然后通过对对等体配置相关参数生效于对等体组内的对等体设备</p>\n<p>​\t分为 External 和 Internal ，External 表示 EBGP 对等体组，Internal 表示 IBGP 对等体组</p>\n<p>​\t例如，group 1 External // 创建 EBGP 对等体组 1</p>\n<p>​\tgroup 2 Internal // 创建 IBGP 对等体组 2</p>\n<p>​\tpeer 对等体 group 1 // 加入组 1 为 EBGP 对等体</p>\n<p>​\tPeer 对等体 group 2 // 加入组 2 为 IBGP 对等体</p>\n<p>注 由于 IBGP 对等体组 AS 号与本地相同，所以对等体 AS 号直接生成，EBGP 对等体 AS 号未知，需要指定 AS 号，peer 1 as-number * //1 为 EBGP 对等体组号</p>\n<p>peer 2 connect loopback 0 // 与对等体组 2 的所有设备用环回口建立关系、</p>\n<p>BGP 安全性，</p>\n<pre><code>1. 防止建立非法BGP对等体关系，bgp认证\n2. 防止设备发送大量非法BGP报文占用CPU,GTSM\n</code></pre>\n<p>GTSM，通过 TTL 安全保护机制，通过设置与合法设备交互 BGP 报文的有效条数，决定收到的合法 BGP 报文的 TTL，如果收到的 BGP 报文在有效跳数内，正常接收，否则丢弃</p>\n<p>公式 ，TTL=(255-HOPS+1,255),HOPS 为设置的有效跳数</p>\n<p>路由反射器组网，</p>\n<p>​\t备份 RR 组我，多个 RR 指定相同的 BGP 路由器作为自己的客户端，并且 RR 多设置相同的集群 ID</p>\n<p>​\t多集群同级 RR 组网，所有路由器只作为 RR 身份</p>\n<p>​\t多集群分级 RR 组网，路由器不仅作为 RR，还作为其他 RR 的客户端（只为 RR 为一级 RR, 作为一级 RR 的客户端身份的 RR 为二级 RR…）</p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1671610768740.png\" alt=\"1671610768740\"></p>\n<h4 id=\"vlan聚合\"><a class=\"markdownIt-Anchor\" href=\"#vlan聚合\">#</a> VLAN 聚合：</h4>\n<p>传统 VLAN 划分如果想要实现 VLAN 间通信需要为每一个 VLAN 设置 VLANIF 逻辑接口，并为其设置 IP 地址，并且每一个 VLAN 都属于不同子网，会造成 IP 地址的浪费（一个 VLAN 至少有三个 IP 地址不能使用，VLANIF 地址，子网段网络地址和广播地址），通过 VLAN 聚合技术减少 IP 地址的浪费</p>\n<h5 id=\"super-vlan\"><a class=\"markdownIt-Anchor\" href=\"#super-vlan\">#</a> Super VLAN ：</h5>\n<p>聚合 VLAN，只包含三层 VLANIF 逻辑接口，作为所有 Sub VLAN 内 PC 的网关，Sub VLAN 间通信通过 SuperVLAN</p>\n<h5 id=\"sub-vlan\"><a class=\"markdownIt-Anchor\" href=\"#sub-vlan\">#</a> Sub VLAN：</h5>\n<p>子 VLAN , 只包含二层物理接口，实现二层广播域的划分，相同 SubVLAN 内二层互通，不同 SubVLAN 二层互相隔离</p>\n<p><strong>注：一个 SuperVLAN 可以设置多个 SubVLAN，一个 SubVLAN 只能绑定一个 SuperVLAN，一个 SuperVlan 下的所有 SubVlan 属于同一个网段</strong></p>\n<p>不同 SubVLAN 间通信：由于目的地与自身处于相同网段，所以直接发送 ARP 广播请求报文，SuperVLAN 也能收到，开启 SuperVLAN 的 SubVLAN 间代理功能后，SuperVLAN 会将收到的广播 ARP 会发送给所有的 SubVLAN，目的设备也能收到，收到后回复 ARP 响应，至此达到通信的目的</p>\n<p>Subvlan 内设备与其他 VLAN（不属于 SubVLAN）设备二层通信：正常发送数据，由于 SuperVLAN 不包含物理接口，所以数据所携带的标签不会发生变化，可与其他相同 VLANTag 的 PC 直接通信</p>\n<p>二层通信：通过 SuperVLAN 进行三层路由互通</p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1671677451957.png\" alt=\"1671677451957\"></p>\n<h5 id=\"mux-vlan\"><a class=\"markdownIt-Anchor\" href=\"#mux-vlan\">#</a> Mux VLAN：</h5>\n<p>分为主 VLAN，从 VLAN，主 Vlan 唯一并且可以与所有从 VLAN 通信，从 VLAN 分为互通型从 VLAN 和隔离型从 VLAN</p>\n<p>​\t<strong>主 VLAN</strong>：PrincipalVLAN, 在一个 MuxVLAN 中只会有一个，并且主 VLAN 下的设备可以与 Muxvlan 内所有设备互通</p>\n<p>​\t<strong>互通型从 VLAN</strong>：GroupVLAN, 属于相同 VLAN 的设备之间能够互通，不同互通 VLAN 之间互相隔离，也不能与隔离 vlan 通信，可以与主 VLAN 通信</p>\n<p>​\t<strong>隔离型从 VLAN</strong>：SeparateVLAN, 属于隔离 VLAN 的设备不能与相同 VLAN 内 / 互通 VLAN 通信，只能与主 VLAN 通信（一个 MuxVLAN 只能有一个隔离型从 VLAN）</p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1671679308345.png\" alt=\"1671679308345\"></p>\n<h5 id=\"qinq\"><a class=\"markdownIt-Anchor\" href=\"#qinq\">#</a> QinQ:</h5>\n<p>802.1Q in 802.1Q，传统的 VLAN 数据帧只能携带一层 VLAN Tag，最多存在 4096 个 VLAN（0-4095，可用 4094 个），vlan 资源有限，为了扩展 VLAN 空间，通过 QinQ 的技术，在原有基础上增加一层 TAG，外层为公网 Tag，内存为私网 Tag，最多可存在 4096*4096 个 VLAN (可用 4094 * 4904)</p>\n<h6 id=\"数据转发\"><a class=\"markdownIt-Anchor\" href=\"#数据转发\">#</a> 数据转发：</h6>\n<p>私网内部通过私网 Tag 正常转发，在进入公网时加上一层所属的公网 Tag，通过外层公网 Tag 在公网进行转发，进入私网时将外层公网 Tag 剥离，再通过内层私网 TAG 转发至目标设备</p>\n<h6 id=\"分类\"><a class=\"markdownIt-Anchor\" href=\"#分类\">#</a> 分类：</h6>\n<p>​\t基本 QinQ：为一个私网局域网设置一个公网 Tag，无论内网的哪一个 VLAN 数据进入公网都加上统一的公网 tag</p>\n<p>​\t灵活 QinQ：可以为内网不同的 vlan 设置不同的公网 Tag，内网数据进入公网时，根据设置的策略加上对应的公网 tag</p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1671693084166.png\" alt=\"1671693084166\"></p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1671694832837.png\" alt=\"1671694832837\"></p>\n<p>端口隔离，可以将设备的端口加入端口隔离组，处于相同隔离组的端口所连接的终端无法通信</p>\n<p>背景，想要实现终端之间二层隔离，通常会将端口划分为不同 VLAN，但是会浪费有限的 Vlan 资源，通过端口隔离技术，既能够实现报文二层隔离，又能够节约 VLAN 资源</p>\n<p>隔离类型，</p>\n<p>​\t双向隔离，端口加入同一个隔离组后，互相不能通信</p>\n<p>​\t单向隔离，在接口视图下，指定该端口与另一个端口之间的单向隔离，该接口不能与指定的端口通信，但是对端可以将数据发送给本端口</p>\n<p>隔离模式，</p>\n<p>​\tL2，二层隔离三层互通（缺省），需要开启 VlanIF 的 vlan 内 ARP 代理功能，实现处于相同隔离组的端口三层通信</p>\n<p>​\tALL，二层三层都隔离，处于同一个隔离组的端口之间彻底隔离无法通信</p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1672711912633.png\" alt=\"1672711912633\"></p>\n<p>MAC 地址表安全，</p>\n<p>​\t动态 MAC 地址表项，交换机动态学习报文的源 MAC 所形成的 MAC 地址表项</p>\n<p>​\t静态 MAC 地址表项，手工配置 MAC 地址与端口的映射关系所形成的表项，优先级高于动态表项</p>\n<p>​\t黑洞 MAC 地址表项，配置为黑洞 MAC 的 MAC 地址类型于加入黑名单，交换机接收到源 MAC / 目的 MAC 为黑洞 MAC 的报文直接丢弃</p>\n<p>​\tMAC 地址表项老化时间，默认 300 是，可以修改，0 为不老化，可以修改（防止 MAC 地址表项爆炸式增长）</p>\n<p>​\t禁止 MAC 地址学习功能，默认交换机的 MAC 地址学习功能已使能，可以关闭，关闭后交换机不再形成该端口对应报文的源 MAC 表项（收到报文的动作默认转发，可以设置为丢弃）</p>\n<p>​\t限制 MAC 地址表项学习数量，可以设置交换机端口学习 MAC 地址的最大数量，超过数量的可以丢弃报文（修改动作，默认转发）/ 告警</p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1672717033943.png\" alt=\"1672717033943\"></p>\n<p>端口安全，</p>\n<p>​\t安全动态 MAC 地址，开启端口安全后动态学习的 MAC 地址，</p>\n<p>​\t特点，默认不会老化，可以设置老化时间，设备重启会丢失</p>\n<p>​\t使用场景，适用于存在大量不固定终端的场景</p>\n<p>​\t安全静态 MAC 地址，开启端口安全后手工配置 MAC 地址表项</p>\n<p>​\t特点，不会被老化，保存配置后重启不会丢失</p>\n<p>​\t使用场景，存在少量固定终端</p>\n<p>​\tSticky MAC 地址，粘贴 MAC 地址，开启了端口安全的同时使能了 Sticky MAC 功能后转换的地址（动态学习 / 手工添加）</p>\n<p>​\t特点，不会被老化，保存配置后重启不会丢失</p>\n<p>​\t适用场景，存在大量固定终端</p>\n<p>​\t限制 MAC 地址学习数量，开启端口安全，默认端口学习 MAC 地址数量为 1，超出数量的采取安全保护动作</p>\n<p>​\t安全保护动作，</p>\n<p>​\tprotect，丢弃源 MAC 不存在的报文</p>\n<p>​\t（缺省）restrict，丢弃源 MAC 不存在的报文并告警</p>\n<p>​\tshutdown，端口被设置为 error-down，并告警</p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1672731713406.png\" alt=\"1672731713406\"></p>\n<p>MAC 地址漂移防止与检测，</p>\n<p>​\t防止低优先级端口覆盖高优先级端口，修改端口的 mac 地址学习优先级，默认为 0，优先级高的端口可以覆盖优先级低的，低优先级不能覆盖高优先级</p>\n<p>​\t配置不允许相同优先级端口发送漂移，默认可以发生，undo 后可以防止</p>\n<p>​\t基于 Vlan 检测 mac 地址漂移，发生漂移后可执行动作告警 / 关闭端口 / 阻断 MAC 地址</p>\n<p>​\t基于全局检测 mac 地址漂移，发生漂移后可执行动作告警 / 关闭端口 / 退出 VLAN</p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1672736115087.png\" alt=\"1672736115087\"></p>\n<p>MACsec，保证二层数据传输的可靠性，具有数据完整性检查，数据加密，真实性校验等机制保障数据传输的安全性</p>\n<p>CAK，安全连接关联密钥，为点到点两端预相同配置连接密钥</p>\n<p>KEY Server，通过预配置参数选举，决定加密方案（生成数据加密密钥）（key server 是通过 MKA，MACsec 数据加密协商协议选举）</p>\n<p>SAK，key Server 生成的数据密钥，用于真实数据传输时进行加密（安全关联密钥）</p>\n<p>流量抑制，</p>\n<p>​\t入方向，针对接收的数据设置相关 阈值（广播 / 组播 / 单播）从而控制数据的发送速率（超过阈值部分丢弃，阈值内可以通过）</p>\n<p>​\t出方向，阻断广播 / 组播 / 单播报文</p>\n<p>广播风暴，在数据入反向对数据进行控制，设置相关阈值，在阈值范围内的数据可以通过，不在范围内的数据完全丢弃并设置相关惩罚动作（阻断报文 / 关闭端口），阻断不在范围内的报文只有超过阈值的报文不能通过，关闭端口后所有报文都不能通过）</p>\n<p>DHCP Snooping，防止针对 DHCP 漏洞攻击，通过信任功能，绑定表等实现</p>\n<p>攻击手段，</p>\n<p>​\tDHCP 饿死攻击，非法设备通过伪造 DHCP 客户端请求报文的源 MAC 地址，不断向服务器请求 IP 地址等网络参数，直至耗尽服务器的地址，导致合法客户端没有地址可以（饿死）</p>\n<p>​\t解决，设置交换机端口学习 MAC 地址的数量，防止非法设备修改 MAC 地址</p>\n<p>​\t改变 CHADDR 字段的 Dos 攻击，非法设备通过修改 DHCP 报文中的 CHADDR 字段（源 MAC 不变）不停的向服务器请求 IP 地址（DHCP 服务器通过 CHADDR 字段分配地址），直至耗尽地址池的地址，当合法设备需要地址时服务器没有地址可分配（拒绝服务）</p>\n<p>​\t解决，交换机 DHCP Snooping 可以检查收到的 DHCP 报文中 CHADDR 字段是否与源 MAC 一致，一致则正常处理，不一致则丢弃报文（防止修改 CHADDR 字段）</p>\n<p>​\tDHCP 中间人攻击，非法设备利用 ARP 致使客户端和服务器学习到错误的 ARP 映射关系（对于客户端，服务器 IP - 非发设备 MAC，对于服务器，客户端 IP - 非法设备 MAC），客户端和服务器之间交互的所有报文都经过非法设备转发，可能会造成信息泄露 / 信息被篡改等安全隐患</p>\n<p>​\t解决，交换机可以形成 DHCP Snooping 绑定表，表中记录了正确的客户端和服务器信息（IP 地址，MAC 地址，vlan，接口等对应关系），当交换机收到 DHCP 报文时，可以对报文以及接收到的接口信息与绑定表做对比，信息一致才能正常处理，否则丢弃报文</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/01/24/2022.12.15/",
            "url": "http://example.com/2023/01/24/2022.12.15/",
            "title": "HCIP(二十二) 2022.12.15",
            "date_published": "2023-01-24T04:30:55.838Z",
            "content_html": "<h4 id=\"mpls-ldp\"><a class=\"markdownIt-Anchor\" href=\"#mpls-ldp\">#</a> MPLS LDP</h4>\n<h5 id=\"ldp\"><a class=\"markdownIt-Anchor\" href=\"#ldp\">#</a> LDP：</h5>\n<p>​\t标签分发协议，LSR 之间建立 LDP 会话关系，互相交换报文，动态建立 LSP</p>\n<h5 id=\"ldp的关系类型\"><a class=\"markdownIt-Anchor\" href=\"#ldp的关系类型\">#</a> LDP 的关系类型：</h5>\n<p>​\tLDP 邻接体 —&gt;LDP 会话 —&gt;LDP 对等体</p>\n<h5 id=\"lsr-id-和ldp-id\"><a class=\"markdownIt-Anchor\" href=\"#lsr-id-和ldp-id\">#</a> LSR ID 和 LDP ID:</h5>\n<p>​\tLSR ID 用于在 MPLS 中唯一标识一台 LSR</p>\n<p>​\tLDP ID 由 ID + 标签空间标识符组成</p>\n<p><strong>注：标签空间标识符如果为 0，表示标签空间是基于设备（或基于平台），如果非 0，表示是基于接口的标签空间，一般为 0，所以 LDP ID=LSR ID :0</strong></p>\n<h5 id=\"ldp的工作过程\"><a class=\"markdownIt-Anchor\" href=\"#ldp的工作过程\">#</a> LDP 的工作过程：</h5>\n<pre><code>1. 运行LDP的LSR组播发送Hello报文，周期性5s发送，通过交互Hello报文，LSR之间可以建立LDP的邻接体关系（老化时间15s，Hello报文基于UDP的646端口发送）\n2. Hello报文中携带了LSR的传输地址，传输地址大的一端会主动发起TCP连接，后续报文基于TCP连接交互（传输地址默认为LSR ID）\n3. TCP 连接建立完成后通过交互Init报文和KeepAlive报文建立LDP会话关系，会话建立完成后LSR互为LDP对等体\n</code></pre>\n<h5 id=\"ldp的工作过程分为三个阶段\"><a class=\"markdownIt-Anchor\" href=\"#ldp的工作过程分为三个阶段\">#</a> LDP 的工作过程分为三个阶段：</h5>\n<p>​\t发现阶段（hello）—》会话阶段 —》通告阶段（交互 FEC 与标签映射关系等）</p>\n<p>​\t注：如果发生错误，会交互 Notification 报文，为差错阶段</p>\n<h5 id=\"ldp的状态机\"><a class=\"markdownIt-Anchor\" href=\"#ldp的状态机\">#</a> LDP 的状态机：</h5>\n<ol>\n<li>\n<p>Non-existent：初始化状态，建立 LDP 邻接体关系</p>\n</li>\n<li>\n<p>Init：TCP 连接建立完成</p>\n</li>\n<li>\n<p>Opensent：主动端发送了 Init 报文后进入此状态</p>\n</li>\n<li>\n<p>OpenRec：</p>\n<ol>\n<li>被动方收到主动发可接受的 Init 报文后进入此状态，并回复 Init 和 KeepAlive 报文</li>\n<li>主动方收到被动方可接收的 Init 报文进入此状态，并回复 KeepAlive 报文</li>\n</ol>\n</li>\n<li>\n<p>Operational：主动方 / 被动方收到了对端发送的 KeepAlive 报文后进入此状态，表示 LDP 会话建立完成</p>\n</li>\n</ol>\n<h5 id=\"标签发布与管理\"><a class=\"markdownIt-Anchor\" href=\"#标签发布与管理\">#</a> 标签发布与管理：</h5>\n<h6 id=\"标签发布方式默认du\"><a class=\"markdownIt-Anchor\" href=\"#标签发布方式默认du\">#</a> 标签发布方式：（默认 DU）</h6>\n<p>​\tDU: 下游自主，不管上游是否向自己请求标签，都会主动将标签映射关系发布给上游</p>\n<p>​\tDoD：下游按需，只有上游向自己请求了标签，才会向上游发布</p>\n<h6 id=\"标签控制方式默认有序\"><a class=\"markdownIt-Anchor\" href=\"#标签控制方式默认有序\">#</a> 标签控制方式：（默认有序）</h6>\n<p>​\tIndependent：独立，不管该 FEC 是否存在出标签，都可以为其分配入标签发布给上游</p>\n<p>​\tOrdered：有序，只有该 FEC 存在对应的出标签，才会为其分配入标签发布给上游</p>\n<h6 id=\"标签保留方式默认自由\"><a class=\"markdownIt-Anchor\" href=\"#标签保留方式默认自由\">#</a> 标签保留方式：（默认自由）</h6>\n<p>​\tLiberal：自由，不管是不是自己最优的下一跳给自己的标签，都保留</p>\n<p>​\tConservative：保守，只有自己最优的下一跳的标签才会保留</p>\n<p><strong>注：标签保留方式与标签发布方式关联，当发布方式为 DU 时，保留方式为自由，发布方式为 DoD 时，保留方式为保守</strong></p>\n<h5 id=\"php\"><a class=\"markdownIt-Anchor\" href=\"#php\">#</a> PHP:</h5>\n<p>​\t次末跳弹出，在 MPLS 标签转发时，连接 FEC 目的网络的最后一跳路由器始终需要执行弹出标签以及查表转发的动作，压力过大，容易成为故障点，为了减轻最后一跳设备的压力，设置 PHP，使最后一条设备向倒数第二跳分配特殊标签（默认为隐式空标签 3），倒数第二跳在转发数据时，发现出标签为特殊标签哦，执行弹出动作，将 IP 数据转发给最后一跳，最后一跳只需要查表转发即可</p>\n<h6 id=\"隐式空标签和显示空标签\"><a class=\"markdownIt-Anchor\" href=\"#隐式空标签和显示空标签\">#</a> 隐式空标签和显示空标签：</h6>\n<p>​\tPHP 默认最后一条分配隐式空标签 3，次末跳在弹出标签时会丢失 Qos 信息（类似报文优先级），在部署了 Qos 的场景下需要保留 Qos 信息，此时可以设置最后一跳给次末跳分配显示空标签 0，次末跳在弹出标签时可以保留 Qos 信息</p>\n<p>设置：</p>\n<ol>\n<li>底层路由可达</li>\n<li>设置 MPLS LSR-ID</li>\n<li>全局开启 mpls</li>\n<li>全局开启 mpls ldp</li>\n<li>物理接口开启 mpls</li>\n<li>物理接口开启 mpls ldp</li>\n</ol>\n<p>查看：</p>\n<ol>\n<li>display mpls ldp peer //<strong> 查看 ldp 的邻居</strong></li>\n<li>display mpls ldp session //<strong> 查看 ldp 的会话</strong></li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/01/24/2022.12.14/",
            "url": "http://example.com/2023/01/24/2022.12.14/",
            "title": "HCIP(二十一) 2022.12.14",
            "date_published": "2023-01-24T04:30:55.835Z",
            "content_html": "<h4 id=\"mpls\"><a class=\"markdownIt-Anchor\" href=\"#mpls\">#</a> MPLS :</h4>\n<p>​\t多协议标签交换</p>\n<h5 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\">#</a> 背景：</h5>\n<p>​\t网络发展初期，设备的硬件条件低，按照传统的查表转发数据效率低下，想要提高数据的转发速度，研究出了 MPLS 协议，通过给数据加上对应的 MPLS 标签，然后设备按照标签转发数据，提高转发效率</p>\n<p>注：到现在为止，设备硬件已经发展较好，MPLS 的作用不再是加快转发效率，而是由于 MPLS 的其他特性可以结合多种协议使用</p>\n<h5 id=\"相关概念\"><a class=\"markdownIt-Anchor\" href=\"#相关概念\">#</a> 相关概念：</h5>\n<p>​\tMPLS 域：由运行了 MPLS 的路由器组成，在域内，数据通常通过标签转发</p>\n<p>​\tLSR：标签交换路由器，运行了 MPLS 的路由器</p>\n<p>​\tLER：标签边缘路由器，处于 MPLS 域边界的路由器，一般执行压入 / 弹出标签的动作</p>\n<p>​\tFEC：转发等价类，一组具有相同特性的数据流的集合，一般指一条路由就是一个 FEC</p>\n<p>​\t入站 LSR：ingress，为数据执行压入标签的动作（加上标签）</p>\n<p>​\t中转 LSR：Transit，将携带 MPLS 标签的数据执行交换标签的动作</p>\n<p>​\t出站 LSR：Egress，为数据执行弹出标签的动作（拆掉标签）</p>\n<p>注：入站 / 出战 LSR 是根据数据区分，角色不固定</p>\n<h5 id=\"lsp\"><a class=\"markdownIt-Anchor\" href=\"#lsp\">#</a> LSP：</h5>\n<p>​\t标签交换路径，数据在 MPLS 域内所经过的路径（从不同设备进入 MPLS 域时 LSP 不相同；同一个 FEC 转发时标签相同）</p>\n<h5 id=\"mpls的报文格式\"><a class=\"markdownIt-Anchor\" href=\"#mpls的报文格式\">#</a> MPLS 的报文格式：</h5>\n<p>​\t二层帧头 + MPLS 标签头部 + IP 头部</p>\n<h6 id=\"mpls标签头部\"><a class=\"markdownIt-Anchor\" href=\"#mpls标签头部\">#</a> MPLS 标签头部：</h6>\n<p>​\tLable：标签空间，20bit</p>\n<p>​\tEXP：服务类别</p>\n<p>​\tS：栈底标识，如果置位为 1，表示是最后一层标签（MPLS 支持多层标签嵌套）</p>\n<p>​\tTTL：8bit，生成时间，防环</p>\n<h6 id=\"标签空间\"><a class=\"markdownIt-Anchor\" href=\"#标签空间\">#</a> 标签空间：</h6>\n<p>​\t是一个短而定长，只具有本地意义的标识符，标签空间就是指标签的范围，</p>\n<p>0-15 为特殊标签，</p>\n<p>16-1023 静态 LSP</p>\n<p>1024 及以上 LDP (标签分发协议，动态建立 LSP)</p>\n<h6 id=\"动作\"><a class=\"markdownIt-Anchor\" href=\"#动作\">#</a> 动作：</h6>\n<p>​\tPush：压入，给数据加上一个标签（一个 / 多个）</p>\n<p>​\tSwap：交换，将数据的最外层标签进行交换</p>\n<p>​\tPop：弹出，将数据拆除标签（一个 / 多个）</p>\n<p>​</p>\n<p>MPLS 标签转发过程：（例）</p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1671000647498.png\" alt=\"1671000647498\"></p>\n<p>R1(Ingress)————R2(Transit)————R3(Egress)————&gt; FEC ：4.4.4.4</p>\n<ol>\n<li>入节点 R1 接收到一个普通的 IP 数据，根据目的 IP4.4.4.4 查找 FIB，发现对应的 Tunnel ID 非 0，表示进行隧道转发（标签）</li>\n<li>根据 Tunnel ID（隧道 ID） 找到对应的动作是压入标签，并且下一跳是 R2（还有出接口，标签等信息），从接口带标签发送出去</li>\n<li>R2 接收到携带 MPLS 标签的数据后，根据入标签找到对应的 Tunnel ID, 然后根据 Tunnel ID 找到动作作为交换标签，把数据中携带的入标签交换为对应的出标签，然后从出接口发送给下一跳设备 R3</li>\n<li>R3 接收到携带 MPLS 标签的数据后，根据入标签查找到的动作作为弹出标签，然后将 MPLS 标签头部拆除，在根据头部的目的 IP 进行普通的 IP 转发</li>\n</ol>\n<p>配置:</p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1671002656341.png\" alt=\"1671002656341\"></p>\n<ol>\n<li>入站 LSR：</li>\n<li><strong>static-lsp ingress 1 destination 3.3.3.3 32 nexthop 10.1.12.2 out-label 100</strong></li>\n<li>中转 LSR：</li>\n<li><strong>static-lsp transit 1 incoming-interface GigabitEthernet0/0/0 in-label 100 nexthop 10.1.23.3 out-label 200</strong></li>\n<li>出站 LSR：</li>\n<li><strong>static-lsp egress 1 incoming-interface GigabitEthernet0/0/0 in-label 200</strong></li>\n</ol>\n<p>查看配置：</p>\n<ol>\n<li>display mpls lsp  // 查看 LSP 信息</li>\n<li>display mpls static-lsp // 查看静态 LSP 信息</li>\n<li>display fib // 查看转发信息表</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/01/24/2022.12.13/",
            "url": "http://example.com/2023/01/24/2022.12.13/",
            "title": "HCIP(二十) 2022.12.13",
            "date_published": "2023-01-24T04:30:55.833Z",
            "content_html": "<h4 id=\"dhcp\"><a class=\"markdownIt-Anchor\" href=\"#dhcp\">#</a> DHCP：</h4>\n<p>​\t动态主机配置协议，使用 UDP 传输报文，67 端口（服务器）和 68 端口（客户端）</p>\n<h5 id=\"报文类型通过option53携带\"><a class=\"markdownIt-Anchor\" href=\"#报文类型通过option53携带\">#</a> 报文类型：（通过 Option53 携带）</h5>\n<pre><code>1. DHCP Discover \n2. DHCP Offer\n3. DHCP Request\n4. DHCP Decline ：当客户端获取的IP地址发生冲突时，通过该报文通知服务器\n5. DCHP Ack\n6. DHCP Nak\n7. DHCP release\n8. DHCP inform ：客户端想要获取更加详细的配置参数，通过该报文向服务器请求\n</code></pre>\n<h5 id=\"服务器向客户端分配ip地址的顺序\"><a class=\"markdownIt-Anchor\" href=\"#服务器向客户端分配ip地址的顺序\">#</a> 服务器向客户端分配 IP 地址的顺序：</h5>\n<pre><code>1. 静态绑定MAC地址的IP0\n2. 使用过的IP（客户端在向服务器请求IP地址时，会利用Option50携带自己曾经用过的地址，期望服务器分配该地址）\n3. 空闲的IP地址\n4. 超过租期的IP地址\n5. 产生冲突的IP地址\n</code></pre>\n<h5 id=\"dhcp-relay\"><a class=\"markdownIt-Anchor\" href=\"#dhcp-relay\">#</a> DHCP relay：</h5>\n<p>​\tDHCP 中继，当客户端和服务器不在一个二层广播域，正常发送的广播报文无法进行传递，需要将连接客户端的三层设备设置为 DHCP 中继，客户端服务器传递交互的报文</p>\n<h6 id=\"工作过程\"><a class=\"markdownIt-Anchor\" href=\"#工作过程\">#</a> 工作过程：</h6>\n<p>​       客户端 ——————–中继 —————— 服务器</p>\n<ol>\n<li>— 广播 discover ——-| 单播 discover———》</li>\n<li>《———offer———|——offer———</li>\n<li>— 广播 request———| 单播 request———》</li>\n<li>《———ACK ———-|——ACK———</li>\n</ol>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1670912905122.png\" alt=\"1670912905122\"></p>\n<p>DHCP-Relay</p>\n<p>中继连接终端的端口：</p>\n<p>dhcp select relay</p>\n<p>dhcp relay server-ip 10.1.12.2</p>\n<p>// 向一个服务器请求</p>\n<p>或者</p>\n<p>dhcp server group 1</p>\n<p>dhcp-server 10.1.12.2</p>\n<p>中断连接终端的端口：</p>\n<p>dhcp select relay</p>\n<p>dhcp relay server-ip server-select 1</p>\n<p>// 向多个服务器请求（设置服务器组）</p>\n<p>路由器通过 DHCP 获取地址：</p>\n<p>ip address dhcp-alloc</p>\n<p>5489-987B-308E</p>\n<p>​</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/01/24/2022.12.12/",
            "url": "http://example.com/2023/01/24/2022.12.12/",
            "title": "HCIP(十九) 2022.12.12",
            "date_published": "2023-01-24T04:30:55.830Z",
            "content_html": "<h4 id=\"vrrp\"><a class=\"markdownIt-Anchor\" href=\"#vrrp\">#</a> VRRP:</h4>\n<p>​\t虚拟路由器冗余协议，使用 IP 的协议号<strong> 112</strong>，使用组播地址<strong> 224.0.0.18</strong> 发送报文</p>\n<p>​</p>\n<h5 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\">#</a> 背景：</h5>\n<pre><code>1. 解决单个网关造成的单点故障\n2. 解决多个网关造成的IP地址冲突\n</code></pre>\n<h5 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\">#</a> 原理：</h5>\n<p>​\t通过将多个物理路由器逻辑为一个虚拟路由器，再为虚拟路由器设置对应的虚拟 IP 地址作为终端的网关地址，<strong>虚拟 MAC 前 5 字节固定 0x0000-5e00-01xx</strong>，其中 XX 为 VRID 转换为十六进制所得</p>\n<p>注：虚拟路由器之间通过<strong> VRID 区分</strong>，构成虚拟路由器的物理设备称之为 VRRP 路由器，<strong>分为 Master 和 Backup</strong></p>\n<p>两种角色，其中 Master 用于承载终端访问其他网络产生的数据，Backup 作为 Master 的备份</p>\n<h6 id=\"master的选举\"><a class=\"markdownIt-Anchor\" href=\"#master的选举\">#</a> Master 的选举：</h6>\n<pre><code>1. 通过VRRP优先级，范围0-255，数值越大越优，其中**0和255保留**，0用于使Backup快速成为Master，255给真实IP地址拥有者（虚拟IP）\n2. 优先级相同时，比较接口IP地址，越大越优 (如果此时已经存在Master，不会继续比较IP )\n</code></pre>\n<p>注：Backup 作为 Master 的备份，会监听 Master 发送的报文，VRRP 中只有一个报文 Advertisement（通告报文），<strong>默认周期性每 1s</strong> 发送一次，Backup 如果再 Master Down 时超时没有收到 ADV 报文，就认为 Master 不在，自己成为 Master</p>\n<p>Master_DOWN=(3*Adv_int)+Skew_Time (偏移时间)</p>\n<p>Skew_Time=(256-Priority)/256</p>\n<h5 id=\"vrrp的状态变化\"><a class=\"markdownIt-Anchor\" href=\"#vrrp的状态变化\">#</a> VRRP 的状态变化：</h5>\n<p>​\tInit：初始化状态，开启 VRRP 时的状态</p>\n<p>​\tBackup：备份状态，当自己的优先级小于 255 时，先进入 Backup (收到优先级比自己大的报文也会进入此状态)</p>\n<p>​\tMaster：活跃状态，优先级等于 255 时直接成为 master（收到优先级比自己小 / Master_down 时间超时会进入此状态）</p>\n<h5 id=\"vrrp主备回切\"><a class=\"markdownIt-Anchor\" href=\"#vrrp主备回切\">#</a> VRRP 主备回切：</h5>\n<pre><code>1. Master 设备退出备份组，会主动发送优先级为0的报文，让Backup迅速成为Master\n2. Master设备故障/链路故障，导致Backup无法接收到Master的报文，等待Master_Down超时，Backup成为Master\n3. 由于VRRP默认开启抢占并且立即抢占，当故障的Master重新恢复时/网络不稳定，会造成主备设备频繁切换，数据丢失，可以设置VRRP的非抢占模式（关闭抢占）或者设置VRRP的抢占延时\n</code></pre>\n<p>配置：</p>\n<p>interface GigabitEthernet0/0/0</p>\n<p>ip address 10.1.1.20 255.255.255.0  //<strong> 物理 ip 地址</strong></p>\n<p>vrrp vrid 1 virtual-ip 10.1.1.254 //<strong> 设置 VRID1 的虚拟 IP 地址</strong></p>\n<p>vrrp vrid 2 virtual-ip 10.1.1.253</p>\n<p>vrrp vrid 2 priority 200 //<strong> 设置优先级</strong></p>\n<p>vrrp vrid 1 preempt-mode disable //<strong> 关闭抢占</strong></p>\n<p>vrrp vrid 1 preempt-mode timer delay 15 //<strong> 设置抢占延时 15s</strong></p>\n<p>vrrp vrid 1 track interface GigabitEthernet0/0/1 reduced 101 //<strong> 监视上行端口</strong> （检测直连故障）</p>\n<p>vrrp vrid 1 track bfd-session session-name 1 reduced 110 //<strong>VRRP 联动 BFD 会话检测链路连通性</strong>（检测直连 / 非直连故障）</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/12/07/2022.12.7/",
            "url": "http://example.com/2022/12/07/2022.12.7/",
            "title": "HCIP(十六） 2022.12.7",
            "date_published": "2022-12-07T12:42:31.528Z",
            "content_html": "<h5 id=\"igmp特性\"><a class=\"markdownIt-Anchor\" href=\"#igmp特性\">#</a> IGMP 特性：</h5>\n<h6 id=\"igmp-snooping\"><a class=\"markdownIt-Anchor\" href=\"#igmp-snooping\">#</a> IGMP Snooping：</h6>\n<p>​\t由于路由器一般都会通过交换机与终端相连，在运行了 IGMP 之后，虽然查询器形成了对应的组播表项，但是交换机收到组播报文后默认执行泛洪行为，无论 PC 加入哪一个组播组，都会收到所有组播组的组播数据，开启交换机的 igmp snooping 功能后，交换机会侦听查询器和组播成员交互的 IGMP 报文，形成二层转发表项（组播组对应端口），收到组播数据后，按照二层转发表项将数据转发给正确的接收者 。</p>\n<h6 id=\"igmp-ssm-mapping\"><a class=\"markdownIt-Anchor\" href=\"#igmp-ssm-mapping\">#</a> IGMP SSM-mapping:</h6>\n<p>​\t在 PC 不支持 IGMPv3 时，想要支持 SSM 模型，需要在查询器上配置 SSM Mapping 的组播组和组播源静态映射关系，形成对应的组播表项（SSM 组地址范围 232.0.0.0-232.255.255.255）</p>\n<h6 id=\"igmp-proxy\"><a class=\"markdownIt-Anchor\" href=\"#igmp-proxy\">#</a> IGMP Proxy：</h6>\n<p>​\tIGMP 代理，为了减少查询器处理的 IGMP 报文数量，代理设备会过滤掉组成员发送的不必要的 IGMP 报文（例如有新成员加入时，加入的组播组已经存在组播表项，代理设备就不会将成员关系报告报文发送给查询器）</p>\n<h4 id=\"pim\"><a class=\"markdownIt-Anchor\" href=\"#pim\">#</a> PIM：</h4>\n<p>协议无关组播，使用 IP 的协议号 103，使用组播地址 224.0.0.13 发送报文</p>\n<h5 id=\"组播分发树\"><a class=\"markdownIt-Anchor\" href=\"#组播分发树\">#</a> 组播分发树：</h5>\n<p>​\tSPT (最短路径树)，RPT（共享树）</p>\n<h5 id=\"pm-dm\"><a class=\"markdownIt-Anchor\" href=\"#pm-dm\">#</a> PM DM:</h5>\n<p>​\tPIM Dense Mode，密集模式，适用于组播接收者分布密集的场景，采用推（Push）的方式</p>\n<h6 id=\"工作过程\"><a class=\"markdownIt-Anchor\" href=\"#工作过程\">#</a> 工作过程：</h6>\n<ol>\n<li>\n<p>邻居发现：运行 PIM DM 的路由器互相交互 hello 报文，协商参数，建立 PIM 邻居关系以及选举 DR，周期性 30s 发送，老化时间 105s，选举 DR 通过 DR 优先级，越大越优，优先级相同比较 IP 地址，越大越优，DR 作为 IGMPv1 查询器，没有其他意义</p>\n</li>\n<li>\n<p>扩散：PIM DM 认为网络中所有地方都存在接收者，当收到组播数据时，会向所有邻居扩散组播数据，沿途路由器都形成（S,G）表项，建立 SPT 树，（S,G）表项老化时间 210s</p>\n</li>\n<li>\n<p>RPF 检查：反向路径转发，收到组播数据的路由器第一时间都是进行 RPF 检查，避免次优路径，重复数据以及转发环路问题</p>\n</li>\n<li>\n<p>Assert 断言：组播路由器在转发组播数据时，如果从下游接口收到了相同的组播数据（多台设备拥有同一个下游设备，需要进行竞选避免重复数据），触发 Assert 断言机制，交互 Assert 报文竞选，竞选成功的作为 Assert Winner 继续转发组播数据，竞选失败的作为 Assert Loser 将端口从下游接口删除，Loser 会侦听 Winner 发送组播数据，如果超过 180s 没有接收到 Winner 的数据，重新参与竞选</p>\n<p>竞选规则：</p>\n<ol>\n<li>比较去往组播源的单播协议优先级，优先级小的优</li>\n<li>比较去往组播源的开销，越小越优</li>\n<li>比较下游接口 IP 地址，越大越优</li>\n</ol>\n</li>\n<li>\n<p>Prune 剪枝：当组播路由收到组播数据后，发现没有下游接口，不需要组播数据，此时会主动向上游发送剪枝消息，上游收到剪枝消息后，会将收到消息的端口从下游接口删除，不再向该端口转发组播数据（Assert 断言的失败者 Loser 如果没有其他下游接口也会向上游剪枝）</p>\n</li>\n<li>\n<p>状态刷新：由于剪枝存在一个计时器 210s，计时器超时后会重新恢复为下游接口，需要重复剪枝动作，为了维持剪枝状态，第一跳路由器会周期性 60s 发送状态刷新报文，刷新剪枝计时器，使其一直维持剪枝状态</p>\n</li>\n<li>\n<p>Graft 嫁接：如果已经剪枝的路由器重新有了接收者，需要接收组播数据，可以主动向上游发送 Graft 消息请求加入下游接口，反向建立组播转发路径，上游收到嫁接消息后，回复 Graft-Ack 确认，将端口重新加入下游接口</p>\n</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/12/07/2022.12.6/",
            "url": "http://example.com/2022/12/07/2022.12.6/",
            "title": "HCIP(十五) 2022.12.6",
            "date_published": "2022-12-07T06:00:20.382Z",
            "content_html": "<h4 id=\"igmp\"><a class=\"markdownIt-Anchor\" href=\"#igmp\">#</a> IGMP:</h4>\n<p>​\t因特网组管理协议</p>\n<p>对于最后一跳路由器：需要感知网络中是否存在组播接收者以及存在哪些组播组的接收者</p>\n<p>对于组播成员：需要声明自己加入哪一个组播组</p>\n<p>IGMP 分为 v1 ，v2，v3 三个版本</p>\n<h5 id=\"igmpv1\"><a class=\"markdownIt-Anchor\" href=\"#igmpv1\">#</a> IGMPv1：</h5>\n<h6 id=\"普遍组查询报文\"><a class=\"markdownIt-Anchor\" href=\"#普遍组查询报文\">#</a> 普遍组查询报文：</h6>\n<p>​\t由 IGMP 查询器周期性 60s 发送，用来查询网络中是否存在组播组接收者 (IGMPv1 无法自己选查询器，需要依靠组播路由协议 PIM 选举）</p>\n<p>​\t目的地址为 224.0.0.1 表示查询所有组</p>\n<h6 id=\"成员关系报告报文\"><a class=\"markdownIt-Anchor\" href=\"#成员关系报告报文\">#</a> 成员关系报告报文：</h6>\n<p>​\t由组播接收者发送，用来告诉查询器要加入哪一个组播组，目的地址为自己加入的组播组地址</p>\n<h6 id=\"响应抑制机制\"><a class=\"markdownIt-Anchor\" href=\"#响应抑制机制\">#</a> 响应抑制机制：</h6>\n<p>​\t接收者回应成员关系报告报文时存在在响应抑制机制，在收到查询器的查询报文后，启动一个计时器 1-10s</p>\n<p>，计时器超时后回应成员关系报告报文，如果发现相同组播组已经有终端回应了成员关系报告报文，自身不再发送</p>\n<h6 id=\"离组机制\"><a class=\"markdownIt-Anchor\" href=\"#离组机制\">#</a> 离组机制：</h6>\n<p>​\tIGMPv1 中组成员静默离开，离组时不发送任何报文，查询器通过 130s (查询报文时间 * 健壮系数 2 + 最大响应抑制时间 10s) 没有收到成员关系报告报文判断没有接收者，从而删除对应的组播表项</p>\n<p>multicast routing-enable</p>\n<p>interface Gigabit Ethernet 0/0/0</p>\n<p>pim dm 开启 PIM 选举查询器<br>\n igmp enable  开启 igmp<br>\nigmp version 1 设置版本</p>\n<p>配置静态</p>\n<p>igmp static-group 组地址</p>\n<h5 id=\"igmpv2\"><a class=\"markdownIt-Anchor\" href=\"#igmpv2\">#</a> IGMPv2:</h5>\n<p>​\t相比 v1 来说做了一些改进，新增加了离开报文，并且自主选举查询器</p>\n<h6 id=\"查询器选举\"><a class=\"markdownIt-Anchor\" href=\"#查询器选举\">#</a> 查询器选举：</h6>\n<p>​\t当存在多个路由器能够向网段转发组播数据，需要选举出查询器，通过发送普遍组查询报文选举，接口 IP 地址小的作为查询器，负责周期性发送查询报文，选举失败的路由器会监听查询器发送的查询报文，如果 125s 没有收到查询报文，则认为查询器不在，自己重新成为查询器</p>\n<h6 id=\"成员离开报文\"><a class=\"markdownIt-Anchor\" href=\"#成员离开报文\">#</a> 成员离开报文：</h6>\n<p>​\t组成员离开主动发送离开报文，通知查询器不再接收某个组播组的数据 ，目的地址为 224.0.0.2 （表示发送给所有路由器）</p>\n<h6 id=\"特定组查询报文\"><a class=\"markdownIt-Anchor\" href=\"#特定组查询报文\">#</a> 特定组查询报文：</h6>\n<p>​\t查询器收到成员离开报文后，需要知道网络中是否还存在该组的其他接收者，通过发送特定组查询报文查询，1s 一次，发两次，如果收到了该组的成员关系报告报文，则保留组播表项，如果没有收到则删除对应的表项，<strong>报文目的地址为查询的组播组地址</strong></p>\n<p>注：IGMPv2 在报文中新增了一个最大响应时间字段，表示组播接收者需要在响应时间内发送成员关系报告报文（响应抑制机制），v2 的响应时间可以修改，1-25s，默认 10s（如果接收者少，可以将最大响应时间改小一点，加快成员报告报文的发送，接收者数量多就可以把时间改大，减少成员关系报告报文的重复发送）</p>\n<p>接口下：</p>\n<p>​\tigmp max-response-time 1-25s</p>\n<h5 id=\"igmpv3\"><a class=\"markdownIt-Anchor\" href=\"#igmpv3\">#</a> IGMPv3：</h5>\n<p>​\tIGMPv1 和 IGMPv2 都适用与 ASM 模型，无法指定组播源，在 SSM 模型下需要指定组播源，可以通过 IGMPv3 实现</p>\n<h6 id=\"报文\"><a class=\"markdownIt-Anchor\" href=\"#报文\">#</a> 报文：</h6>\n<p>​\t普遍组查询报文，特定组查询报文，特定源组查询报文</p>\n<h6 id=\"模式\"><a class=\"markdownIt-Anchor\" href=\"#模式\">#</a> 模式：</h6>\n<p>​\tInclude：表示加入某个组播，并且只愿意接收某些组播源发往该组的数据，例如：</p>\n<p>​\t（S1,S2,S3,G1 include）表示加入 G1 这个组组播，并且在接收组播数据时只接收 S1/S2/S3 发送的组播数据，其他组播源发送的不接受</p>\n<p>​</p>\n<p>​\tExclude：表示加入某个组播组，但是需要过滤某些组播源发送的组播数据，例如：</p>\n<p>​\t（S1,S2,S3,G1 exclude）表示加入 G1 这个组播组，并且接收除了 S1/S2/S3 之外所有组播源发送的组播数据</p>\n<p>​</p>\n<p>​\tchange_to_include_mode：模式改变为 include，原本是 exclude 过滤某些组播源发送的数据，现在改变为愿意接收（如果模式改变为 include 后，没有指定组播源，表示不接收这个组播组的数据，表示离组）</p>\n<p>​</p>\n<p>​\tchange_to_exclude_mode: 模式改变为 exclude，原本是 include 愿意接收某些组播源发送的组播数据，现在改变为不愿意接收（如果模式改变为 exclude 后，没有指定组播源，表示接收发往这个组播组的所有组播数据）</p>\n<p>​</p>\n<p>​\tAllow_new_source: 增加新的源，增加接收组播数据的组播源，如果原本是 include 模式，就是在原有基础上增加，如果是 exclude 模式，就是在原有的基础上删除</p>\n<p>​\tBlock_old_source：删除旧的源，删除原本接收组播数据的组播源，如果原本是 include，就是在原有的基础上删除，如果是 exclude，就是在原有的基础上增加</p>\n<p>​</p>\n<p>​\t注：IGMPv3 没有定义专门的离开报文，通过改变成员关系报告报文的模式离开，并且成员关系报告报文的目的地址为 224.0.0.22（表示发送给所有运行 IGMPv3 的路由器）</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/12/07/2022.12.2/",
            "url": "http://example.com/2022/12/07/2022.12.2/",
            "title": "HCIP(十四) 2022.12.2",
            "date_published": "2022-12-07T06:00:20.380Z",
            "content_html": "<h4 id=\"ip组播基础\"><a class=\"markdownIt-Anchor\" href=\"#ip组播基础\">#</a> IP 组播基础</h4>\n<p>​\t组播：一对多发送业务数据（点到多点业务）</p>\n<p>​\t使用单播承载点到多点业务会导致重复流量以及带宽占用严重的问题</p>\n<p>​\t使用广播承载点到多点业务会存在安全隐患</p>\n<p>​\t使用组播承载既没有重复流量不会占用链路带宽，也可以提高数据安全性</p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1669965936622.png\" alt=\"1669965936622\"></p>\n<p>组播 IP 地址：224.0.0.0 — 239.255.255.255</p>\n<p>组播 MAC 地址：0x01-00-5e - 第 25bit 位为 0，后 23bit 由组播 IP 映射</p>\n<p>注：由于组播 IP 地址前 4bit 固定为 1110，后 23bit 映射为组播 MAC，中间 5bit 丢失，会造成 32 个组播 IP 地址映射到同一个组播 MAC 地址</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>范围</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">224.0.0.0—224.0.0.255</td>\n<td>为路由协议预留的永久组地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">224.0.1.0—231.255.255.255    233.0.0.0—238.255.255.255</td>\n<td>Any-Source 临时组播组地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">232.0.0.0—232.255.255.255</td>\n<td>Source-Specific 临时组播组地址</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">239.0.0.0—239.255.255.255</td>\n<td>本地管理的 Any-Source 临时组播组地址</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"组播服务模型\"><a class=\"markdownIt-Anchor\" href=\"#组播服务模型\">#</a> 组播服务模型：</h5>\n<p>​\tASM：任意源组播，组播组成员（接收组播数据的设备）只关心数据是不是发往自己所在的组播组，不关心是谁发送的数据</p>\n<p>​\tSSM：指定源组播，组播组成员不仅关心数据是不是发往自身所在的组播组，还关心是谁发送的组播数据</p>\n<h5 id=\"组播网络架构\"><a class=\"markdownIt-Anchor\" href=\"#组播网络架构\">#</a> 组播网络架构：</h5>\n<p>源端网络：组播源 - 第一跳路由器（接收到组播数据的第一个三层组播设备）</p>\n<p>组播转发网络：由组播路由器组成，帮忙转发组播数据的网络</p>\n<p>成员端网络：最后一跳路由器 - 组播组成员（接收组播数据的接收者）</p>\n<p>组播转发数据时可能会出现环路，重复数据，次优路劲等问题，可以通过 RPF 检查解决</p>\n<h5 id=\"rpf\"><a class=\"markdownIt-Anchor\" href=\"#rpf\">#</a> RPF:</h5>\n<p>​\t反向路径转发，通过确定去往组播源最优的出接口来保障组播路由器接收到最优的组播数据</p>\n<h6 id=\"检查过程\"><a class=\"markdownIt-Anchor\" href=\"#检查过程\">#</a> 检查过程：</h6>\n<pre><code>1. 组播路由器接收到组播数据\n2. 根据组播数据中的源IP地址查找对应最优的出接口\n3. 检查接收到组播数据的入接口与对应最优的出接口是否一致\n4. 接口一致则接收数据，不一致则丢弃\n</code></pre>\n<h6 id=\"rpf路由选举确定最优出接口\"><a class=\"markdownIt-Anchor\" href=\"#rpf路由选举确定最优出接口\">#</a> RPF 路由选举（确定最优出接口）：</h6>\n<ol>\n<li>将单播路由协议 / MBGP / 组播静态路由中去往组播源的路由作为备选 RPF 路由</li>\n<li>从备选路由中选则掩码最长的</li>\n<li>掩码相同 选择协议路由优先级最高的（小）</li>\n<li>优先级相同 组播静态 &gt; MBGP &gt; 单播路由</li>\n</ol>\n<p>注：所有组播路由器</p>\n<p>在接收到组播数据时都需要进行 RPF 检查，检查通过才能接收</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/12/07/2022.12.1/",
            "url": "http://example.com/2022/12/07/2022.12.1/",
            "title": "HCIP(十三) 2022.12.1",
            "date_published": "2022-12-07T06:00:20.378Z",
            "content_html": "<h4 id=\"交换机堆叠与集群\"><a class=\"markdownIt-Anchor\" href=\"#交换机堆叠与集群\">#</a> 交换机堆叠与集群</h4>\n<p>堆叠：istack，可以将多台支持堆叠特性的物理交换机虚拟为一台逻辑交换机（一般是盒式交换机）</p>\n<p>集群：CSS，可以将两台支持集群特性的物理交换机虚拟为一台逻辑交换机（一般是框式交换机）</p>\n<h5 id=\"堆叠系统\"><a class=\"markdownIt-Anchor\" href=\"#堆叠系统\">#</a> 堆叠系统：</h5>\n<p>通过堆叠技术形成的虚拟交换机由多台物理交换机组成，交换机角色分为主交换机，备交换机，从交换机</p>\n<p>​\t主交换机：负载收集成员交换机信息以及管理成员交换机</p>\n<p>​\t备交换机：会同步主交换机的信息，作为主交换机的备份</p>\n<p>​\t从交换机：主要负载业务数据的转发</p>\n<h5 id=\"堆叠id\"><a class=\"markdownIt-Anchor\" href=\"#堆叠id\">#</a> 堆叠 ID：</h5>\n<p>在对端系统中唯一标识一台交换机，缺省堆叠 ID 为 0，当一个堆叠系统中堆叠 ID 冲突时，会由主交换机重新分配</p>\n<h5 id=\"堆叠连接方式\"><a class=\"markdownIt-Anchor\" href=\"#堆叠连接方式\">#</a> 堆叠连接方式：</h5>\n<p>​\t堆叠卡堆叠：通过专用的堆叠接口和堆叠线缆连接进行堆叠</p>\n<p>​\t业务口堆叠：利用现有的业务接口连接，再将业务接口加入堆叠逻辑接口进行堆叠</p>\n<h5 id=\"堆叠逻辑接口\"><a class=\"markdownIt-Anchor\" href=\"#堆叠逻辑接口\">#</a> 堆叠逻辑接口：</h5>\n<p>stack port n/1 和 stack port n/2 ，其中 n 为设备的堆叠 ID，再进行堆叠时，设备连接其他物理设备的逻辑接口必须是 n/1 连接 n/2（n/2 连接 n/1）</p>\n<h5 id=\"堆叠拓扑类型\"><a class=\"markdownIt-Anchor\" href=\"#堆叠拓扑类型\">#</a> 堆叠拓扑类型：</h5>\n<p>​\t链形连接：容易增加新的成员设备，但是可靠性更低（某条链路 / 设备故障堆叠系统就断开了）</p>\n<p>​\t环形连接：增加新的设备需要先断开环，然后增加，但是可靠性更高</p>\n<h5 id=\"堆叠系统组建过程\"><a class=\"markdownIt-Anchor\" href=\"#堆叠系统组建过程\">#</a> 堆叠系统组建过程：</h5>\n<pre><code>1. 物理连接，上电\n2. 选举主交换机\n3. 主交换机收集拓扑信息，分配堆叠ID等\n4. 将信息同步给成员交换机后稳定运行               \n</code></pre>\n<h5 id=\"主交换机选举\"><a class=\"markdownIt-Anchor\" href=\"#主交换机选举\">#</a> 主交换机选举：</h5>\n<ol>\n<li>比较堆叠系统启动时间，已经稳定运行的优先与处于启动状态的交换机，20s 以内认为是同时启动</li>\n<li>比较堆叠优先级，越大越优</li>\n<li>比较 MAC 地址，越小越优</li>\n</ol>\n<h5 id=\"堆叠成员退出\"><a class=\"markdownIt-Anchor\" href=\"#堆叠成员退出\">#</a> 堆叠成员退出：</h5>\n<ol>\n<li>从交换机退出，更新拓扑信息进行同步即可</li>\n<li>备交换机退出，重新选举新的备交换机，然后更新拓扑信息</li>\n<li>主交换机退出，备交换机成为新的主交换机，再选举一个备交换机，更新拓扑信息</li>\n</ol>\n<h5 id=\"堆叠成员加入\"><a class=\"markdownIt-Anchor\" href=\"#堆叠成员加入\">#</a> 堆叠成员加入：</h5>\n<p>​\t一个未上电的设备连接到堆叠系统中之后再启动，自动成为从交换机</p>\n<h5 id=\"堆叠合并\"><a class=\"markdownIt-Anchor\" href=\"#堆叠合并\">#</a> 堆叠合并：</h5>\n<p>​\t两个稳定运行的堆叠系统连接再一起，两个主交换机之间进行竞选，竞选成功的继续为主交换机，竞选失败的成为从交换机</p>\n<h5 id=\"堆叠分裂\"><a class=\"markdownIt-Anchor\" href=\"#堆叠分裂\">#</a> 堆叠分裂：</h5>\n<p>​\t一个堆叠系统断开后成为多个堆叠吸引</p>\n<pre><code>1. 主备交换机在一个堆叠系统的更新拓扑信息\n2. 主备不在一个堆叠系统，主交换机所在可以重新选举备交换机，备交换机所在备交换机成为主交换机，重新选举新的备交换机\n3. 分裂后只有从交换机的重新选举主交换机和备交换机\n</code></pre>\n<p>注：堆叠系统分裂会造成地址冲突的问题，导致网络故障</p>\n<h6 id=\"mad\"><a class=\"markdownIt-Anchor\" href=\"#mad\">#</a> MAD：</h6>\n<p>多主检测，检测堆叠分裂后的冲突问题，分裂后的堆叠系统之间进行竞选，竞选成功的正常运行，竞选失败的关闭所有物理端口（除了管理员手动保留的）</p>\n<h6 id=\"检测方式\"><a class=\"markdownIt-Anchor\" href=\"#检测方式\">#</a> 检测方式:</h6>\n<p>​\t直连检测：</p>\n<ol>\n<li>\n<p>中间设备直连检测，通过一台专用的物理设备进行 MAD 检测，不承载其他业务，所有成员交换机与中间设备相连</p>\n</li>\n<li>\n<p>Full-mesh 直连检测，所有成员交换机两两互连，通过检测链路交互 MAD 报文检测</p>\n<p>注：直连检测在分裂前不交互报文，分裂后每 1s 交互 MAD 检测报文</p>\n</li>\n</ol>\n<p>代理检测：</p>\n<ol>\n<li>\n<p>单机代理检测：连接方式与中间设备直连检测一直，检测设备检测同时可以承载业务</p>\n</li>\n<li>\n<p>堆叠系统互为代理：不同堆叠系统之间互相作为 MAD 检测设备，交互 MAD 报文</p>\n<p>注：代理检测在发生分裂前每 30s 交互 MAD 检测报文，分裂后每 1s 交互</p>\n</li>\n</ol>\n<h6 id=\"mad竞选过程\"><a class=\"markdownIt-Anchor\" href=\"#mad竞选过程\">#</a> MAD 竞选过程：</h6>\n<ol>\n<li>多个堆叠系统的主交换机比较启动时间，先启动的优先竞选成功，20s 内认为相同</li>\n<li>主交换机之间比较堆叠优先级，大的竞选成功</li>\n<li>优先级相同比较 MAC 地址，小的竞选成功</li>\n</ol>\n<h5 id=\"堆叠升级\"><a class=\"markdownIt-Anchor\" href=\"#堆叠升级\">#</a> 堆叠升级：</h5>\n<pre><code>1. 智能升级：所有成员交换机同步主交换机的软件版本和配置信息\n2. 传统升级：设置好堆叠系统下一次启动的软件版本和配置信息，然后进行重启，会造成业务中断\n3. 平滑升级：将堆叠系统划分为Active区域和Backup区域，Backup区域升级时Active区域承载业务，backup区域升级完再升级Active区域，此时Backup区域承载业务，可以保证业务不中断\n</code></pre>\n<h5 id=\"跨设备链路聚合\"><a class=\"markdownIt-Anchor\" href=\"#跨设备链路聚合\">#</a> 跨设备链路聚合：</h5>\n<p>​\t设备通过堆叠技术形成一个虚拟交换机后，不同物理交换机上的链路可以进行跨设备的链路聚合，可以对流量进行负载分担</p>\n<h5 id=\"流量本地优先转发\"><a class=\"markdownIt-Anchor\" href=\"#流量本地优先转发\">#</a> 流量本地优先转发：</h5>\n<p>​\t对于成员交换机在转发数据时会进行负载均衡，一部分数据会通过堆叠线缆转发给其他成员交换机承载，此时会造成堆叠线缆负担过重，利用设置流量本地优先转发，只要本交换机存在出接口能够转发数据就不会让其他成员交换机转发</p>\n<h5 id=\"集群\"><a class=\"markdownIt-Anchor\" href=\"#集群\">#</a> 集群：</h5>\n<p>CSS，将两台支持集群特性的框式交换机虚拟为一台逻辑交换机</p>\n<h6 id=\"结构\"><a class=\"markdownIt-Anchor\" href=\"#结构\">#</a> 结构：</h6>\n<p>主交换机，备交换机</p>\n<h6 id=\"集群id\"><a class=\"markdownIt-Anchor\" href=\"#集群id\">#</a> 集群 ID：</h6>\n<p>在集群中唯一标识，默认集群 ID 为 1</p>\n<h6 id=\"css-link\"><a class=\"markdownIt-Anchor\" href=\"#css-link\">#</a> CSS link：</h6>\n<p>集群链路，集群成员交换机之间作用集群链路</p>\n<h6 id=\"集群优先级\"><a class=\"markdownIt-Anchor\" href=\"#集群优先级\">#</a> 集群优先级：</h6>\n<p>默认为 1，越大越优选举为主交换机</p>\n<h5 id=\"集群建立方式\"><a class=\"markdownIt-Anchor\" href=\"#集群建立方式\">#</a> 集群建立方式：</h5>\n<p>​\t传统 CSS: 主控板集群卡建立集群和业务口集群，集群卡需要通过专用的集群线缆建立集群，业务空需要加入集群逻辑接口进行集群</p>\n<p>​\tCSS2: 第二代集群，通过交互网板集群卡集群</p>\n<p>注：传统 CSS 在转发流量时，同框 / 不同框流量都需要经过主控板，所以两台成员交换机都必须至少有一个可用的主控板</p>\n<p>同框数据经过本地接口版 — 本地主控版 — 本地接口</p>\n<p>不同框数据经过本地接口版 — 本地主控板 — 本地集群卡 — 对端集群卡 — 对端主控板 — 对端接口板</p>\n<p>注：CSS2 转发数据直接通过交换网板，不需要经过主控板，实现了转控分离，具有 “集群主控 1+N 备份” 特性（整个集群只要有一个主控板能正常工作集群就能正常运行）</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/12/01/2022.11.30/",
            "url": "http://example.com/2022/12/01/2022.11.30/",
            "title": "HCIP(十三) 2022.11.30",
            "date_published": "2022-11-30T23:29:55.508Z",
            "content_html": "<h5 id=\"rstpr的工作过程\"><a class=\"markdownIt-Anchor\" href=\"#rstpr的工作过程\">#</a> RSTPR 的工作过程：</h5>\n<pre><code>1. 初始所有交换机都认为自己是根桥。端口都为指定端口，处于Discarding状态\n2. 所有交换机互相交互RST BPDU ，选举根桥，非根桥选举根端口，链路选举指定端口（选举方式与STP一致）\n3. DP指定端口与根端口RP之间通过P/A协商进入转发状态（DP会继续发送P置位RST BPDU,RP收到后设备进入同步状态，端口进入Forwarding状态，并且回复A置位RST BPDU, DP收到A置位RST BPDU 进入Forwarding状态）\n4. DP指定端口与AP替代端口之间通过慢收敛过程，DP进入转发状态（DP继续发送P置位RST BPDU ，AP作为阻塞端口 不会发送任何报文，DP无法收到A置位RST BPDU, 一直发送P置位RST BPDU, 直至2个Forward delay 30s 后进入 Forwarding状态 ）\n</code></pre>\n<h4 id=\"mstp\"><a class=\"markdownIt-Anchor\" href=\"#mstp\">#</a> MSTP</h4>\n<p>​\t多生成树协议</p>\n<p>背景：STP/RSTP 单生成树的缺陷</p>\n<pre><code>1. 流量无法负载分担\n2. 二层次优路径\n3. 阻塞链路资源利用率低\n</code></pre>\n<p>在 MSTP 中，交换机之间可以形成多个生成树，不同的生成树之间通过 Instance id 区分，默认存在一个实列 0，针对不同实例交换机可以设置不同的优先级，指定不同交换机作为实例的根桥，通过在不同实例中阻塞不同的端口提高资源利用率以及解决单生成树的缺陷</p>\n<p>每一个多生成树实例称之为一个 MSTI（MSTP Instance）</p>\n<p>MSTP 可以将交换网络划分成不同的 MST 域，一个域可以形成多个生成树，MST 域通过三个参数进行标识：</p>\n<pre><code>1. 相同的域名\n2. 相同的修订级别\n3. 相同Vlan到实例的映射关系\n</code></pre>\n<p>CST：</p>\n<p>公共生成树，将 MST 域当作一个大的交换机，MST 域之间可能会产生环路，通过形成 CST 进行防环</p>\n<p>IST:</p>\n<p>内部生成树，所有 MST 域的交换机都默认存在实例 0，MSTI 0 所形成的生成树就称之为 IST</p>\n<p>CIST</p>\n<p>公共和内部生成树，CST+IST</p>\n<p>SST:</p>\n<p>单生成树，在一个 MSTI 中只存在一个交换机 / 只形成一个生成树</p>\n<p>总根：指整个交换网络中最优的设备（CIST 的根桥）</p>\n<p>域根：包含 IST 域根和 MSTI 域根，IST 域根指 MST 域中离总根最近的设备（不包含总根），MSTI 域根每一个实例生成树中的根桥</p>\n<p>主桥：MST 域离总根最近的设备，包含总根（IST 域根 + 总根）</p>\n<table>\n<thead>\n<tr>\n<th><strong>角色</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MST 域</td>\n<td>交换网络被划分成多个域，一个 MST 域内可以包含一台或多台交换机，同属于一个 MST 域的交换机必须配置相同的域名、相同的修订级别、以及相同的 VLAN 映射表</td>\n</tr>\n<tr>\n<td>MSTI</td>\n<td>基于 Instance 的生成树</td>\n</tr>\n<tr>\n<td>VLAN 映射表</td>\n<td>VLAN 和 MSTI 之间的映射关系</td>\n</tr>\n<tr>\n<td>CST</td>\n<td>公共生成树，连接所有 MST 域的一棵生成树</td>\n</tr>\n<tr>\n<td>IST</td>\n<td>内部生成树，MST 域内 Instance   ID 为 0 的一棵生成树</td>\n</tr>\n<tr>\n<td>CIST</td>\n<td>公共和内部生成树，连接一个交换网络内所有交换设备的生成树</td>\n</tr>\n<tr>\n<td>SST</td>\n<td>单生成树，MST 域内只有一台交换设备</td>\n</tr>\n<tr>\n<td>总根</td>\n<td>CIST 的根桥</td>\n</tr>\n<tr>\n<td>IST 域根</td>\n<td>MST 域中，IST 距离总根最近的交换设备</td>\n</tr>\n<tr>\n<td>MSTI 域根</td>\n<td>MSTI 的根桥</td>\n</tr>\n<tr>\n<td>主桥</td>\n<td>距离总根最近的交换设备，包括：总根和 IST 域根</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"mstp的端口角色\"><a class=\"markdownIt-Anchor\" href=\"#mstp的端口角色\">#</a> MSTP 的端口角色：</h5>\n<p>​\t根端口，指定端口，替代端口，备份端口</p>\n<p>​\tMaster 端口：是一个特殊的域边缘端口，所有域边缘端口中离总根最近的端口</p>\n<p>​\t域边缘端口：交换机连接不属于本 MST 域设备的端口</p>\n<p>​\t边缘端口：连接终端用户的端口</p>\n<h5 id=\"mstp的工作过程\"><a class=\"markdownIt-Anchor\" href=\"#mstp的工作过程\">#</a> MSTP 的工作过程：</h5>\n<pre><code>1. 交换机之间交互MST BPDU 选举出总根\n2. MST域间形成CST\n3. MST域内形成IST\n4. CST+IST =ICST\n</code></pre>\n<h5 id=\"cist计算向量\"><a class=\"markdownIt-Anchor\" href=\"#cist计算向量\">#</a> CIST 计算向量：</h5>\n<ol>\n<li>根交换设备 ID (选举总根，域根，主桥)</li>\n<li>外部路径开销（选举域根，Master 端口）</li>\n<li>域根 ID（选举域根）</li>\n<li>内部路径开销（选举根端口，指定端口）</li>\n<li>指定交换设备 ID (选举根端口，指定端口)</li>\n<li>指定端口 ID（选举根端口，指定端口）</li>\n<li>接收端口 ID（选举根端口，指定端口）</li>\n</ol>\n<h5 id=\"mstp的数据转发\"><a class=\"markdownIt-Anchor\" href=\"#mstp的数据转发\">#</a> MSTP 的数据转发：</h5>\n<ol>\n<li>域内按照映射的实例生成树转发</li>\n<li>域间按照 CST 转发</li>\n</ol>\n<p>注：MSTP 使用增强版 P/A 机制（P，A 同时置位）</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/11/30/2022.11.29/",
            "url": "http://example.com/2022/11/30/2022.11.29/",
            "title": "HCIP(十二) 2022.11.29",
            "date_published": "2022-11-29T23:30:21.897Z",
            "content_html": "<h4 id=\"rstp\"><a class=\"markdownIt-Anchor\" href=\"#rstp\">#</a> Rstp：</h4>\n<p>​\t快速生成树协议，相比 STP 加快了收敛速度以及做了相应的改进措施</p>\n<h5 id=\"stp的不足\"><a class=\"markdownIt-Anchor\" href=\"#stp的不足\">#</a> STP 的不足：</h5>\n<ol>\n<li>\n<p>STP 中的阻塞端口没有言明是作为根端口还是指定端口的备份，再进入转发状态时还需要重新选举</p>\n</li>\n<li>\n<p>端口状态中 Distable，Blocking，Listening，都不学习 MAC 地址和转发用户流量，对于用户来说作用一致</p>\n</li>\n<li>\n<p>STP 的 MAX Age 为 20s</p>\n</li>\n<li>\n<p>STP 非根交换机再转发配置 BPDU 时需要收到上游转发的 BPDU 才会继续向下转发</p>\n</li>\n<li>\n<p>STP 只有指定端口会处理次优 BPDU</p>\n</li>\n<li>\n<p>STP 中连接终端用户的端口也需要参与生成树计算，用户访问网络需要等待至少 30s 的时间</p>\n</li>\n<li>\n<p>STP 初始化收敛需要两个 Forwarding Delay 转发延迟时间 30s 才能进入稳定运行状态</p>\n</li>\n<li>\n<p>STP 认为一个端口 UP/Down 接收发生拓扑变化，由于发生变化的设备通知根桥后再由根桥通知全网</p>\n</li>\n</ol>\n<h5 id=\"rstp的改进\"><a class=\"markdownIt-Anchor\" href=\"#rstp的改进\">#</a> RSTP 的改进：</h5>\n<ol>\n<li>\n<p>将阻塞端口分为两种角色：AP 替代端口和 BP 备份端口，其中 AP 作为根端口的备份，BP 作为指定端口的备份</p>\n</li>\n<li>\n<p>将端口状态前三种结合为一个 Discarding。Leraning 和 Forwarding 不变</p>\n</li>\n<li>\n<p>RSTP MAX Age 为三倍的 HelloTime 时间（6s）</p>\n</li>\n<li>\n<p>RSTP 中配置 BPDU 的转发完全自主进行（不需要等待上游）</p>\n</li>\n<li>\n<p>RSTP 只要收到了次优 BPDU 就会丢弃并回应自身缓存的最优 BPDU</p>\n</li>\n<li>\n<p>RSTP 新增了一个边缘端口角色，连接终端用户的端口设置为边缘端口后可以立即进入 Forwarding 转发状态，不需要参与生成树计算，但是如果边缘端口收到了 BPDU 就会丧失边缘端口属性，就会重新参与生成树计算</p>\n</li>\n<li>\n<p>P/A 机制：</p>\n</li>\n<li>\n<p>设备之间互相交互 BPDU 后，</p>\n</li>\n<li>\n<p>更优的一端会继续发送 P 置位的 RST BPDU，</p>\n</li>\n<li>\n<p>下游收到 P 置位的 BPDU 后进入同步状态（除了接收到的端口和边缘端口外其他所有端口阻塞），</p>\n</li>\n<li>\n<p>接收到 P 置位 BPDU 的端口进入转发状态，回复 A 置位 RST BPDU</p>\n</li>\n<li>\n<p>上游收到 A 置位 RST BPDU 后端口进入转发状态；</p>\n<p>注：如果是收到 P 置位 RST BPDU 的端口是 AP/BP 则不会回复 A 置位 BPDU，上游由于无法收到 A 置位 RST BPDU 进入慢收敛状态，等待两个转发延迟时间 30s 进入转发状态。</p>\n</li>\n<li>\n<p>RSTP 认为一个非边缘端口进入 Forwarding 状态就是发生了拓扑变化，并且由发生变化的设备通知全网：</p>\n<ol>\n<li>发生变化的端口向外发送 TC 置位 RST BPDU，启动一个计时器（2 倍 HelloTime 时间），超时后停止发送</li>\n<li>收到 TC 置位 RST BPDU 的设备将除了接收到的端口和边缘端口外的其他所有端口学习到的 MAC 地址清空</li>\n<li>继续向下游转发 TC 置位 RST BPDU</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"rstp的保护功能\"><a class=\"markdownIt-Anchor\" href=\"#rstp的保护功能\">#</a> RSTP 的保护功能：</h5>\n<pre><code>1. BPDU保护：由于边缘端口收到BPDU后会丧失边缘端口属性，重新参与生成树计算，引起网络重新收敛，为了防止不法分子向边缘渡口发送BPDU，可以开启BPDU保护，开启保护功能后，边缘端口收到BPDU会立即关闭端口\n2. 根保护：为了防止非法分子伪造更优的BPDU影响根桥的地位。可以再指定端口开启根保护，收到更优BPDU后会将端口状态置为Discarding，一段时间后没有再收到就可以回到Forwarding，如果一直收到则一直处于Discarding状态\n3. 环路保护：为了防止根桥—&gt;RP之间单向链路故障时造成的环路，开启环路保护后，根端口/AP无法收到根桥的BPDU之后会进入Discarding状态，直到重新收到BPDU\n4. 防TC-BPDU攻击：由于RSTP设备在收到TC置位 RST BPDU 后删除MAC地址表项，非法分子利用这一特性向网络中发送大量TC RST BPDU，导致设备一直删除表项，数据都是未知帧形成泛洪，开启防TC-BPDU攻击后，可以设置设备单位时间内处理TC报文的次数，降低影响（例如非法分子1s发了10次，设置2S只处理1次）\n</code></pre>\n<p>1.stp 不会指定 ap 为 dp 或者 rp 的备份端口</p>\n<p>2.stp 的 max age 为 20</p>\n<p>3.stp 的三个端口状态 不会</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/11/29/2022.11.28/",
            "url": "http://example.com/2022/11/29/2022.11.28/",
            "title": "HCIP(十一) 2022.11.28",
            "date_published": "2022-11-28T23:24:49.162Z",
            "content_html": "<h5 id=\"路由反射器\"><a class=\"markdownIt-Anchor\" href=\"#路由反射器\">#</a> 路由反射器:</h5>\n<p>在 AS 内部用于传递路由，解决 IBGP 全互联的问题，包含 RR（路由反射器）和 Client 角色，其余为非客户端</p>\n<p>注：IBGP 全互联需要维护大量的 TCP 连接以及 BGP 对等体关系，并且扩展性较差</p>\n<h6 id=\"rr反射规则\"><a class=\"markdownIt-Anchor\" href=\"#rr反射规则\">#</a> RR 反射规则：</h6>\n<pre><code>1. 从客户端收到的路由可以反射给所有的非客户端和其他的客户端，其他的客户端以及发送给EBGP的对等体\n2. 从非客户端收到的路由可以反射给所有的客户端以及发送给EBGP对等体\n3. 从EBGP对等体收到的路由可以反射给所有的客户端和非客户端；\n</code></pre>\n<h6 id=\"路由反射簇\"><a class=\"markdownIt-Anchor\" href=\"#路由反射簇\">#</a> 路由反射簇：</h6>\n<p>由 RR 以及对应的客户端组成，在 RR 反射路由时，可能会出现环路的问题，可以通过 Originator_ID (起源 ID) 和 Cluster_list (簇列表 / 集群列表) 进行防环</p>\n<p>​\tOriginator_ID：由收到路由的第一个 RR 所添加，表示路由是哪个路由器发送出来的（通过 Router ID 表示），当路由器收到路由包含自身的 RID 则忽略该路由</p>\n<p>​\tCluster_list：由 Cluster_ID 组成，集群 ID 是用来区分不同的路由反射簇的，没有手工指定的情况下默认 RR 的 Router ID ，当 RR 收到一条路由的 Cluster_LIST 中包含自身的集群 ID 则忽略该路由</p>\n<p>注：起源 ID 和集群列表都属于可选非过渡属性</p>\n<h6 id=\"bgp防环\"><a class=\"markdownIt-Anchor\" href=\"#bgp防环\">#</a> BGP 防环：</h6>\n<p>​\tAS 内：</p>\n<ol>\n<li>\n<p>无 RR 通过 IBGP 水平分割防环</p>\n</li>\n<li>\n<p>有 RR 通过起源 ID 和集群列表防环</p>\n<p>AS 间：通过 AS_path 防环</p>\n</li>\n</ol>\n<h5 id=\"bgp选路原则\"><a class=\"markdownIt-Anchor\" href=\"#bgp选路原则\">#</a> BGP 选路原则：</h5>\n<pre><code>1. 丢弃下一跳不可达的路由\n2. 优选Preference_Value值更大的路由\n3. 优选Local_Preference数值更大的路由\n4. 本地始发的路由优于从对等体学习到的路由，本地始发又分为手动聚合&gt;自动聚合&gt;Network&gt;Incomplete\n5. 优选AS_Path短的路由\n6. Origin，I&gt;e&gt;?.\n7. 优选MED值小的路由 , 默认不比较来自不同AS路由的MED值，可以开启强制比较（**compare-different-as-med**）\n8. 从EBGP对等体学习到的优于IBGP对等体学习的\n9. 优选下一跳IGP开销小的路由\n10. 优选Cluster_List短的路由\n11. 优选Originator_ID小的路由\n12. 优选Router ID小的对等体学习到的路由\n13. 优选IP地址小的对等体 学习的路由\n</code></pre>\n<p>注：BGP 支持负载分担（最多 8 条），当选路规则前 9 条都相同并且 AS_Path 属性完全相同的情况下可以进行负载分担，成为等价路由加入 IP 路由表（AS_PATH 属性完全相同指所经过的 AS 号完全相同），但是 BGP 路由表中还是会选出最优的那条路由。默认为 1 条</p>\n<p>BGP 支持聚合：</p>\n<p>​\t手动和自动</p>\n<p>手动聚合：将一些具有相似前缀的路由聚合为一个网段，可以完全控制掩码长度</p>\n<p>自动聚合：针对引入的路由进行聚合，自动聚合为有类路由（A,B,C 类），无法控制掩码（有类路由存在自然掩码）。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/11/29/2022.11.25/",
            "url": "http://example.com/2022/11/29/2022.11.25/",
            "title": "HCIP(十) 2022.11.25",
            "date_published": "2022-11-28T23:24:49.159Z",
            "content_html": "<h5 id=\"bgp的属性\"><a class=\"markdownIt-Anchor\" href=\"#bgp的属性\">#</a> BGP 的属性：</h5>\n<p>​\t公认必遵：表示运行了 BGP 的路由器都能识别，并且必须携带在 Update 报文中，不携带就会出错</p>\n<p>​\t公认任意：所有 BGP 路由都能识别，可以携带也可以不携带，不携带也不会出错</p>\n<p>​\t可选过渡：BGP 路由器可以识别也可以不识别，不识别也能继续向下传递</p>\n<p>​\t可选非过渡：BGP 路由器可以识别也可以不识别，不识别不能向下传递</p>\n<h6 id=\"as_path\"><a class=\"markdownIt-Anchor\" href=\"#as_path\">#</a> AS_path:</h6>\n<p>​\tAS 路径信息，属于公认必遵属性，用来表示路由经过了哪些 AS，每经过一个 AS 就把该 AS 号添加到 AS_Path 的最前面，可以用来选路以及防环</p>\n<p>​\t防环：当路由器收到一条路由的 AS_path 中携带了自身所在的 AS 号，不接收该路由</p>\n<p>​\t选路：当存在去往同一个目的地的多条路由时，优先选择 AS_path 更短的路由</p>\n<p>​\tAS_Sep：有序 AS_Path，后经过的 AS 号添加到 AS_path 前面</p>\n<p>​\tAS_Set：无序 AS_Path, 当路由聚合后，无法判断聚合前经过的 AS 先后顺序，可以携带无序的 AS_Path</p>\n<h6 id=\"origin\"><a class=\"markdownIt-Anchor\" href=\"#origin\">#</a> Origin：</h6>\n<p>​\t起源属性，属于公认必遵属性，用来表示路由是如何进入 BGP 的，分为 IGP（i）,EGP（e）,Incomplete（?）,</p>\n<p>如果是 i，表示路由是通告 Network 宣告进入 BGP，如果是 e，表示路由是通过 EGP 学习到的（由于 EGP 已经被淘汰，正常情况下不存在，但是可以通过路由策略修改），如果是？，表示未知，一般指引入的路由，起源属性可以用于选路：i &gt; e &gt; ?</p>\n<h6 id=\"next_hop\"><a class=\"markdownIt-Anchor\" href=\"#next_hop\">#</a> Next_Hop ：</h6>\n<p>下一跳属性，属于公认必遵属性，表示访问路由的下一跳地址，路由器本地始发的路由在传递给 BGP 对等体时，下一跳地址更新源地址（与对端建立关系的地址），如果不是本地始发路由，下一跳地址在不同情况下不同：</p>\n<pre><code>1. 将路由传递给EBGP对等体时，正常情况为自己的更新源地址\n2. 将路由传递给IBGP对等体，下一跳地址不变（下一跳不可达时路由无效，要使路由生效需要配置下一跳本地：next-hop-local）\n3. 将BGP路由发送给EBGP对等体时，如果自身去往该路由的下一跳与要发布路由的EBGP对等体处于相同网段，下一跳地址不变 \n</code></pre>\n<h6 id=\"local-preference\"><a class=\"markdownIt-Anchor\" href=\"#local-preference\">#</a> Local-Preference :</h6>\n<p>本地优先级，属于公认任意属性，用来指导数据如何出 AS，只在 AS 内部有效，缺省值 100，数值为越大越优，可以用来选路</p>\n<h6 id=\"community\"><a class=\"markdownIt-Anchor\" href=\"#community\">#</a> Community：</h6>\n<p>团体属性，属于可选过渡属性，有两个作用：</p>\n<p>①给路由加上一个团体属性值，将路由分为不同类别，类似于打标机的作用，针对不同的团体属性可以执行不同的策略 (AA:NN 形式 / 十进制形式，AA 为 AS 号，NN 为自定义数值)</p>\n<p>②限制路由的传递范围，四大公认团体属性，internet 整个网络传递，No-Advertise 不传递，No-Export 本 AS 内传递，NO-export-Sub Confed 联盟本子 AS 内传递</p>\n<h6 id=\"med\"><a class=\"markdownIt-Anchor\" href=\"#med\">#</a> MED:</h6>\n<p>多出口鉴别器，属于可选非过渡属性，用于指导数据如何进入 AS，MED 值越小越优，默认只比较来自相同 AS 路由的 MED 值，并且 MED 只在相邻的两个 AS 之间有效</p>\n<p>​\t注：如果是本地的直连 / 静态路由注入到 BGP 中，传递给 EBGP 邻居时，默认 MED 值为 0</p>\n<p>​\t\t如果是通过 IGP 学习到的路由注入到 BGP 中，默认 MED 值为该路由器去往路由的 IGP 开销</p>\n<p>​\t\t可以修改路由器本地的默认 MED 值（只对引入 / 聚合的路由生效）</p>\n<h6 id=\"atomic_aggregate\"><a class=\"markdownIt-Anchor\" href=\"#atomic_aggregate\">#</a> Atomic_Aggregate:</h6>\n<p>​\t原子聚集体，公认任意属性，携带在聚合路由中，用来表示该路由为聚合路由</p>\n<h6 id=\"aggregate\"><a class=\"markdownIt-Anchor\" href=\"#aggregate\">#</a> Aggregate：</h6>\n<p>​\t聚合属性，可选过渡属性，携带在聚合路由中，用来表示聚合路由的聚合点（聚合所在的 AS 号以及 BGP 路由器的 ID）</p>\n<h6 id=\"preference_value\"><a class=\"markdownIt-Anchor\" href=\"#preference_value\">#</a> Preference_Value:</h6>\n<p>协议首选值，华为的私有属性，只在设有本地有效，可用于选路，权重值越大越优，范围 0-65535</p>\n<p>默认为 0</p>\n<h6 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结：</h6>\n<p>​\t公认必遵：AS_path（AS 路径信息），Origin（起源属性），Next_Hop （下一跳属性）</p>\n<p>​\t公认任意：Local-Preference （本地优先级），Atomic_Aggregate（原子聚集体）</p>\n<p>​\t可选过渡：Community（团体属性），Aggregate（聚合属性）</p>\n<p>​\t可选非过渡：MED（多出口鉴别器）</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/11/25/2022.11.24/",
            "url": "http://example.com/2022/11/25/2022.11.24/",
            "title": "HCIP(九) 2022.11.24",
            "date_published": "2022-11-24T23:37:56.593Z",
            "content_html": "<h4 id=\"bgp\"><a class=\"markdownIt-Anchor\" href=\"#bgp\">#</a> BGP：</h4>\n<h6 id=\"as\"><a class=\"markdownIt-Anchor\" href=\"#as\">#</a> AS:</h6>\n<p>自治系统，AS 和 AS 之间通过 AS 号进行区分，AS 号范围 1-65535，其中 1-64511 为公有 AS 号，64512-65535 为私有 AS 号</p>\n<h5 id=\"bgp-2\"><a class=\"markdownIt-Anchor\" href=\"#bgp-2\">#</a> BGP:</h5>\n<p>边界网关协议，用于 AS 与 AS 之间传递和控制路由，属于路径矢量路由协议</p>\n<p>BGP 是应用层协议，基于 TCP 的<strong> 179 端口</strong>建立连接，只有建立了 TCP 连接，才能建立 BGP 连接，由于 TCP 为单播建立连接，所以 BGP 需要手工指定邻居，又因为 TCP 连接建立的基础是网络可达，所以 BGP 只要网络可达就可以建立邻居关系</p>\n<h6 id=\"bgp的邻居类型\"><a class=\"markdownIt-Anchor\" href=\"#bgp的邻居类型\">#</a> BGP 的邻居类型：</h6>\n<p>BGP 邻居关系称之为对等体关系</p>\n<p>​\tIBGP 对等体：处于相同 AS 的两个设备之间建立的 BGP 对等体关系，一般采用环回口建立（需要指定更新源地址为环回口）</p>\n<p>​\tpeer 对端 IP 地址 as-number 对端 AS 号  // 接口地址建立</p>\n<p>​\tPeer 对端 ip 地址 Connect-interface loopback0// 环回口建立必须修改</p>\n<p>​\tEBGP 对等体：处于不同 AS 的两个设备之间建立的 BGP 对等体关系，一般采用直连接口建立，如果用环回口建立需要指定 ebgp 多跳（EBGP 对等体建立时默认 TTL=1）</p>\n<p>​\tpeer 对端 IP 地址 as-number 对端 AS 号</p>\n<p>​\tPeer 对端 ip 地址 Connect-interface loopback0// 环回口建立必须修</p>\n<p>​\tpeer 对等体地址 ebgp-max-hop 1-255（不设具体数据直接回车为最大值）</p>\n<h6 id=\"bgp的报文类型\"><a class=\"markdownIt-Anchor\" href=\"#bgp的报文类型\">#</a> BGP 的报文类型：</h6>\n<p>​\tOPEN 报文：协商参数，建立对等体关系（版本，AS 号，BGP ID ,Hold Time）</p>\n<p>​\tUPdate 报文：传递路由信息（发布和撤销路由）</p>\n<p>​\tNotification：差错报文，当邻居关系发送错误，通过该报文通知对等体断开邻居关系</p>\n<p>​\tKeepalive：保活报文，周期性 60s 发送，用来维护对等体关系，</p>\n<p>​\tRoute-refrash：路由刷新报文，当配置了路由策略，路由信息发生变化，发送该报文通知对等体</p>\n<table>\n<thead>\n<tr>\n<th><strong>报文名称</strong></th>\n<th><strong>作用</strong></th>\n<th><strong>发送时刻</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Open</td>\n<td>协商 BGP 对等体参数，建立对等体关系</td>\n<td>BGP   TCP 连接建立成功之后</td>\n</tr>\n<tr>\n<td>Update</td>\n<td>发送 BGP 路由更新</td>\n<td>BGP 对等体关系建立之后有路由需要发送或路由变化时向对等体发送 Update 报文</td>\n</tr>\n<tr>\n<td>Notification</td>\n<td>报告错误信息，中止对等体关系</td>\n<td>当 BGP 在运行中发现错误时，发送 Notification 报文将错误通告给 BGP 对等体</td>\n</tr>\n<tr>\n<td>Keepalive</td>\n<td>标志对等体建立，维持 BGP 对等体关系</td>\n<td>BGP 路由器收到对端发送的 Keepalive 报文，将对等体状态置为已建立，同时后续定期发送 keepalive 报文用于保持连接</td>\n</tr>\n<tr>\n<td>Route-refresh</td>\n<td>用于在改变路由策略后请求对等体重新发送路由信息。只有支持路由刷新能力的 BGP 设备会发送和响应此报文</td>\n<td>当路由策略发生变化时，触发请求对等体重新通告路由</td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"bgp的状态机\"><a class=\"markdownIt-Anchor\" href=\"#bgp的状态机\">#</a> BGP 的状态机：</h6>\n<p>​\tIdle：初始状态，等待 Start 事件（peer…）</p>\n<p>​\tConnect: 尝试建立 TCP 连接，并启动一个计时器 32s，如果建立成功，则进入 Opensent 状态，建立失败进入 Active 状态，超时重启计时器停留在 connect 状态</p>\n<p>​\tActive：重新启动计时器，建立 TCP 连接，成功进入 Opensent，超时回到 connect，失败停留在 Active</p>\n<p>​\tOpensent：TCP 连接建立成功，开始发送 Open 报文，协商参数</p>\n<p>​\tOpenconfirm：收到了 OPEN 报文并且协商成功进入该状态，开始发送 Keepalive 报文</p>\n<p>​\tEstablished：收到了 Keepalive 报文，对等体关系建立成功</p>\n<p>注：在此期间只要收到了 Notification 报文都会回到 Idle 状态</p>\n<p><img data-src=\"C:%5CUsers%5Cz.j.j%5CDesktop%5Chcip%E5%9F%B9%E8%AE%AD%5Cassets%5C1669276103229.png\" alt=\"1669276103229\"></p>\n<p>看看：：：：</p>\n<p>・Idle 状态是 BGP 初始状态。在 Idle 状态下，BGP 拒绝对等体发送的连接请求。只有在收到本设备的 Start 事件后，BGP 才开始尝试和其它 BGP 对等体进行 TCP 连接，并转至 Connect 状态。</p>\n<p>▫Start 事件是由一个操作者配置一个 BGP 过程，或者重置一个已经存在的过程或者路由器软件重置 BGP 过程引起的。</p>\n<p>▫任何状态中收到 Notification 报文或 TCP 拆链通知等 Error 事件后，BGP 都会转至 Idle 状态。</p>\n<p>・在 Connect 状态下，BGP 启动连接重传定时器（Connect Retry），等待 TCP 完成连接。</p>\n<p>▫如果 TCP 连接成功，那么 BGP 向对等体发送 Open 报文，并转至 OpenSent 状态。</p>\n<p>▫如果 TCP 连接失败，那么 BGP 转至 Active 状态。</p>\n<p>▫如果连接重传定时器超时，BGP 仍没有收到 BGP 对等体的响应，那么 BGP 继续尝试和其它 BGP 对等体进行 TCP 连接，停留在 Connect 状态。</p>\n<p>・在 Active 状态下，BGP 总是在试图建立 TCP 连接。</p>\n<p>▫如果 TCP 连接成功，那么 BGP 向对等体发送 Open 报文，关闭连接重传定时器，并转至 OpenSent 状态。</p>\n<p>▫如果 TCP 连接失败，那么 BGP 停留在 Active 状态。</p>\n<p>▫如果连接重传定时器超时，BGP 仍没有收到 BGP 对等体的响应，那么 BGP 转至 Connect 状态。</p>\n<h6 id=\"bgp注入路由的方式\"><a class=\"markdownIt-Anchor\" href=\"#bgp注入路由的方式\">#</a> BGP 注入路由的方式：</h6>\n<p>​\t两种：network 和 import-route</p>\n<p>​\tnetwork：只要是本地 IP 路由表中存在的路由都可以宣告到 BGP 中（掩码要一致）</p>\n<p>​\tImport-route：可以将不属于 BGP 的路由引入，如直连，静态，OSPF 等</p>\n<p>​\tBGP 路由表中：* 表示有效路由 ，&gt; 表示最优路由</p>\n<p>​\tBGP 发布路由时通过 Update 报文携带 NLRI（网络层可达信息，携带发布的路由前缀和前缀长度）和路径属性（用于选路和防环），撤销路由通过 Update 报文中的 withdraw，携带撤销的路由前缀和前缀长度</p>\n<p>注：在 BGP 中，认为目的地与下一跳一致的路由无效</p>\n<h6 id=\"bgp的通告原则\"><a class=\"markdownIt-Anchor\" href=\"#bgp的通告原则\">#</a> BGP 的通告原则：</h6>\n<pre><code>1. 只发布有效并且最优的路由给对等体\n2. 从EBGP对等体学习到的路由可以传给所有邻居\n3. 从IBGP对等体学习的路由不能传给其他的IBGP（IBGP水平分割，为了防环）\n4. BGP和IGP同步（IBGP和IGP同步，当设备将BGP路由发布给IBGP对等体之前，会先检查本地IGP路由表是否存在该路由，如果存在则发送，不存在则不发，为了避免路由黑洞，华为默认永不开启）\n</code></pre>\n<h6 id=\"路由黑洞\"><a class=\"markdownIt-Anchor\" href=\"#路由黑洞\">#</a> 路由黑洞：</h6>\n<p>由于 BGP 可以跨跳建立对等体关系，所以导致中间设备没有运行 BGP，数据到了这里之后由于没有路由被丢弃</p>\n<h6 id=\"解决方法\"><a class=\"markdownIt-Anchor\" href=\"#解决方法\">#</a> 解决方法：</h6>\n<pre><code>1. IBGP 全互联\n2. 将BGP引入IGP\n3. 物理直连\n4. 隧道\n5. MPLS\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/11/24/2022.11.22/",
            "url": "http://example.com/2022/11/24/2022.11.22/",
            "title": "HCIP(七) 2022.11.22",
            "date_published": "2022-11-23T23:29:59.803Z",
            "content_html": "<h4 id=\"路由策略与路由控制\"><a class=\"markdownIt-Anchor\" href=\"#路由策略与路由控制\">#</a> 路由策略与路由控制：</h4>\n<p>路由策略：可以针对路由的发布，接收，引入进行影响，影响路由的长度 / 学习，从而影响数据的转发可达性</p>\n<p>路由匹配工具：匹配满足条件的路由，最终的动作由路由策略工具决定</p>\n<h6 id=\"acl访问控制列表\"><a class=\"markdownIt-Anchor\" href=\"#acl访问控制列表\">#</a> ACL：访问控制列表</h6>\n<p>分类：基本 ACL（2000-2999），高级 ACL（3000-3999），二层 ACL（4000-4999），用户自定义 ACL（5000-5999），用户 ACL（6000-6999）</p>\n<p>注：只有基本 ACL 可以匹配路由（路由默认拒绝）</p>\n<p>一个 ACL 由多条规则组成，规则之间通过 rule id 进行区分，默认情况下按照 rule id 进行从小到大进行匹配（配置顺序），只要匹配中其中一个即停止匹配，执行相应的动作（permit/deny），如果所有规则都没有匹配上，是路由默认拒绝，是数据默认通过</p>\n<p>注：如果是自动排序则是按照 rule 规则的精确度匹配，越精确的越优先匹配（两种排序发送）</p>\n<p>* 通配符：32bit，与前缀一一对应，通配符为 0 表示对应的前缀必须相同，为 1 表示任意取值</p>\n<h6 id=\"ip-perfix-list\"><a class=\"markdownIt-Anchor\" href=\"#ip-perfix-list\">#</a> IP-Perfix List：</h6>\n<p>IP 前缀列表（只能匹配路由）</p>\n<p>一个前缀列表可以由多个索引组成（index），匹配路由时按照索引号从小到大匹配，步长值为 10，一条索引由动作，前缀，掩码以及掩码范围组成，动作为 permit/deny，前缀和掩码可以确定匹配的路由前缀，掩码范围可以确定匹配的路由掩码长度，如果没有匹配任何 index，默认拒绝</p>\n<p>注：只有一种排序方式，没有自动排序</p>\n<p>配置：</p>\n<p>[Huawei]ip ip-prefix name1 index 10 permit 10.1.1.1 24 greater-equal 26 less-equal 29  <a href=\"//xn--name11010-u02ox2vnhk08fm5li99bgj8cw0hri2d.1.1.0/24%E6%8E%A9%E7%A0%81%E8%8C%83%E5%9B%B4%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E26%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E29%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%9A%E8%BF%87\">// 允许名字 name1 索引号 10 网段 10.1.1.0/24 掩码范围大于等于 26 小于等于 29 的路由通过</a></p>\n<h6 id=\"acl和ip-perfix-list的区别\"><a class=\"markdownIt-Anchor\" href=\"#acl和ip-perfix-list的区别\">#</a> ACL 和 IP-Perfix List 的区别：</h6>\n<p>1、ACL 可以匹配路由以及数据，前缀列表只能匹配路由</p>\n<p>2、ACL 匹配路由时只能匹配前缀，无法匹配前缀长度，前缀列表可以匹配前缀长度</p>\n<p>3、ACl 有配置顺序及自动排序，前缀列表只能按照索引号从小到大匹配</p>\n<p>4、ACl 默认步长为 5，前缀列表默认步长为 10</p>\n<p>5、ACl 按照进程号分为多种，前缀列表就一种</p>\n<h6 id=\"路由策略工具\"><a class=\"markdownIt-Anchor\" href=\"#路由策略工具\">#</a> 路由策略工具：</h6>\n<p>Filter-policy：可以针对路由的发布，接收，引入进行影响，本身没有动作，可以继承匹配工具的动作，匹配工具为 permit 就是允许，匹配工具为 deny 就是拒绝，可以应用于各个协议视图下，如果应用于距离矢量路径协议，<strong>可以在入方向（import）和出方向（export）对路由进行影响，如果是链路状态路由协议，入方向只能影响自己本地不加入 IP 路由表，出方向只能影响引入的路由（引入算发送，是发给邻居传递路由），不能影响链路状态信息的传递</strong></p>\n<p>例：[Huawei-ospf-1] filter-policy 2000 import</p>\n<p>1、先定义匹配工具规则</p>\n<p>2、再通过 filter-policy 调用匹配工具</p>\n<p>[Huawei-ospf-100] filter-policy acl-number/ip-prefix name import  // 对 OSPF 接收的路由进行过滤（调用匹配工具，acl 和前缀列表）</p>\n<p>[Huawei-ospf-100] filter-policy acl-number/ip-prefix name export  // 对 OSPF 引入的路由对外发布时过滤（调用匹配工具，acl 和前缀列表）</p>\n<h6 id=\"route-policy\"><a class=\"markdownIt-Anchor\" href=\"#route-policy\">#</a> Route-Policy：</h6>\n<p>不仅可以对路由的发布，接收，引入进行影响，还可以修改路由的属性</p>\n<p>一个 route-policy 可以定义多个 node 节点，一个 node 节点中可以包含多个 if-match 条件语句和 apply 执行语句，其中 node 节点之间是 “或” 的关系（匹配到一个 node 节点就停止匹配），按照 node 节点号从小到大匹配，node 节点中的 if-match 语句之间是 “与” 的关系，只有满足所有 if-match 语句条件，才是匹配了该 node 节点，如果一个 node 节点都未匹配，底层默认拒绝，node 节点也有匹配模式，permit、deny，只有在 permit 的模式下才会定义 apply 语句</p>\n<table>\n<thead>\n<tr>\n<th>匹配工具 ACL 和 ip 前缀</th>\n<th>Node 节点</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Permit</td>\n<td>Permit</td>\n<td>允许通过，运行 apply 语句</td>\n</tr>\n<tr>\n<td>Permit</td>\n<td>Deny</td>\n<td>拒绝通过</td>\n</tr>\n<tr>\n<td>Deny</td>\n<td>Permit/Deny</td>\n<td>不匹配该 node 节点，继续匹配下一个节点</td>\n</tr>\n</tbody>\n</table>\n<p>[Huawei] route-policy 1 permit node 10  // 创建策略 1 节点 10 并进入视图</p>\n<p>[Huawei-route-policy] if-match acl 2000  // 匹配条件调用 ACL2000</p>\n<p>[Huawei-route-policy] apply cost-type type-1  // 匹配中时执行将开销改为 1 的操作</p>\n<p>[Huawei-ospf-1] filter-policy route-policy 1 import  // 接收路由时调用策略 1</p>\n<p>[Huawei-ospf-1] import-route direct route-policy 1  // 引入路由时调用策略 1</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/11/24/2022.11.21/",
            "url": "http://example.com/2022/11/24/2022.11.21/",
            "title": "HCIP(六) 2022.11.21",
            "date_published": "2022-11-23T23:29:59.801Z",
            "content_html": "<h6 id=\"isis在广播网络lsdb的同步过程\"><a class=\"markdownIt-Anchor\" href=\"#isis在广播网络lsdb的同步过程\">#</a> ISIS 在广播网络 LSDB 的同步过程：</h6>\n<p>​\t在广播网络中，邻接关系建立完成后，会选举 DIS，所有路由器都将自己的 LSP 发往组播地址，DIS 就会有所有的 LSP 信息构建完整的 LSDB，之后通过周期性发送 CSNP 报文进行同步</p>\n<p>​\t如果此时新加入一台设备：</p>\n<p>1. 新加入设备将自己的 LSP 发往组播地址，DIS 收到后加入 LSDB，后续发 CSNP 报文携带摘要</p>\n<p>2. 信加入设备收到 DIS 的 CSNP 报文后可以判断自己缺少了那些 LSP, 然后发送 PSNP 报文进行请求</p>\n<p>3.DIS 收到请求后，将完整的 LSP 信息发送给新加入的设备</p>\n<p>注：广播网络中 PSNP 报文只有请求的作用，不需要确认，通过 DIS 周期性发送 CSNP 报文进行隐式确认</p>\n<h6 id=\"组播地址\"><a class=\"markdownIt-Anchor\" href=\"#组播地址\">#</a> 组播地址：</h6>\n<p>level-1：0180-c200-0014</p>\n<p>level-2：0180-c200-0015</p>\n<h6 id=\"p2p环境下lsdb的同步过程\"><a class=\"markdownIt-Anchor\" href=\"#p2p环境下lsdb的同步过程\">#</a> P2P 环境下 LSDB 的同步过程：</h6>\n<p>R1— — R2</p>\n<ol>\n<li>设备建立完邻接关系后，互相交互 CSNP 报文，判断 LSDB 是否同步</li>\n<li>如果没有同步，通过发送 PSNP 报文向对方请求</li>\n<li>收到 PSNP 请求的设备会将完整的 LSP 信息发送给对端，并启动一个重传计时器 5s</li>\n<li>收到完整 LSP 信息的设备会回复 PSNP 报文进行确认</li>\n<li>如果发送完整 LSP 信息的设备会在重传计时器超时没有收到确认报文，会将 LSP 进行重传，直至收到确认报文为止</li>\n</ol>\n<p>ISIS 进程号（1-65535）</p>\n<p>network-entity 49.0001.0000.0000.0001.00</p>\n<p>is-level 路由器类型</p>\n<p>接口宣告：ISIS enable 进程号</p>\n<p>dis isis lsdb 0000.0000.0001.00-00 verbose 详细信息</p>\n<h6 id=\"isis的路由计算\"><a class=\"markdownIt-Anchor\" href=\"#isis的路由计算\">#</a> ISIS 的路由计算：</h6>\n<p>level-1 路由器：本区域内通过交互 Level-1LSP 进行路由计算，其他区域通过自己产生的默认路由访问</p>\n<p>level-1/2 路由器：访问 Level-1 区域通过 Level-1LSP 计算，访问 Level-2 区域通过 Level-2LSP 计算，默认会将 Level-1 区域的路由传递给 Level-2 区域，不会将 L-2 的路由传递给 L-1 区域</p>\n<p>Level-2 区域路由器：通过交互 Level-2LSP 进行计算（去往 level-1 区域通过 Level-1/2 的 LSP 计算）</p>\n<h6 id=\"att置位条件\"><a class=\"markdownIt-Anchor\" href=\"#att置位条件\">#</a> ATT 置位条件：</h6>\n<p>​\t①是一个 Level-1/2 路由器</p>\n<p>​\t②建立了 Level-2 邻接关系</p>\n<p>​\t③建立了 Level-1 邻接关系</p>\n<p>注：Level-1 路由器的默认路由是通过收到 Level-1/2 设备的 ATT 置位的 L-1LSP 自动产生的，下一跳指向该 L-1/2 设备</p>\n<h6 id=\"路由渗透\"><a class=\"markdownIt-Anchor\" href=\"#路由渗透\">#</a> 路由渗透：</h6>\n<p>​\t由于 Level-1 路由器通过默认路由访问 Level-2 区域，可能会产生次优路径，可以在 Level-1/2 设备上将 Level-2 区域的路由引入到 Level-1 区域，让 Level-1 路由器学习到 Level-2 区域的明细路由，避免次优路径</p>\n<p>​\t在 isis 下配置 impact isis l2 into l1</p>\n<h6 id=\"lsp的新旧比较\"><a class=\"markdownIt-Anchor\" href=\"#lsp的新旧比较\">#</a> LSP 的新旧比较：</h6>\n<p>先比较序列号是否相同，不相同则取序列号大的为优</p>\n<p>相同在比较保活时间是否 = 0s，是则保活时间为 0 的为优</p>\n<p>不为 0，在比较校验和是否相同，不相同取校验和大的为优</p>\n<p>相同则不处理该 LSP.</p>\n<h6 id=\"isis的认证\"><a class=\"markdownIt-Anchor\" href=\"#isis的认证\">#</a> ISIS 的认证：</h6>\n<p>​\t接口认证：针对 ISIS 邻接关系的建立进行认证，认证通过才可以建立邻接关系</p>\n<p>​\t区域认证：针对 Level-1 的 LSDB 进行认证，开启认证后会在发送的 Level-1 报文中携带认证信息（Level-1LSP,Level-1SNP）, 对收到的报文也会进行认证检查，检查通过才可以加入 LSDB</p>\n<p>​\t路由器认证：针对 Level-2 的 LSDB 进行认证，开启认证后会在发送的 Level-2 报文中携带认证信息，对收到的报文也会进行认证检查</p>\n",
            "tags": []
        }
    ]
}